

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_bitwarden_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_bitwarden_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_bitwarden_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)
class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.write_unchecked(cls.check(value), buf)

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("bitwarden_uniffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 25
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_bitwarden_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    pass

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.ffi_bitwarden_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rustbuffer_free.restype = None
_UniffiLib.ffi_bitwarden_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_u8.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_u8.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_bitwarden_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_i8.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_i8.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_bitwarden_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_u16.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_u16.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_bitwarden_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_i16.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_i16.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_bitwarden_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_u32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_u32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_bitwarden_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_i32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_i32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_bitwarden_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_u64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_u64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_bitwarden_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_i64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_i64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_bitwarden_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_f32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_f32.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_bitwarden_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_f64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_f64.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_bitwarden_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_pointer.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_bitwarden_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_rust_future_poll_void.restype = None
_UniffiLib.ffi_bitwarden_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_cancel_void.restype = None
_UniffiLib.ffi_bitwarden_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_rust_future_free_void.restype = None
_UniffiLib.ffi_bitwarden_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_rust_future_complete_void.restype = None
_UniffiLib.ffi_bitwarden_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_bitwarden_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u32(value)

class _UniffiConverterBool(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write_unchecked(cls, value, buf):
        buf.write_u8(value)

    @staticmethod
    def lift(value):
        return value != 0

class _UniffiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = _UniffiConverterString.check(value)
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = _UniffiConverterString.check(value)
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

# The Timestamp type.
Timestamp = datetime.datetime

# There is a loss of precision when converting from Rust timestamps,
# which are accurate to the nanosecond,
# to Python datetimes, which have a variable precision due to the use of float as representation.
class _UniffiConverterTimestamp(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_i64()
        microseconds = buf.read_u32() / 1000
        # Use fromtimestamp(0) then add the seconds using a timedelta.  This
        # ensures that we get OverflowError rather than ValueError when
        # seconds is too large.
        if seconds >= 0:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) + datetime.timedelta(seconds=seconds, microseconds=microseconds)
        else:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) - datetime.timedelta(seconds=-seconds, microseconds=microseconds)

    @staticmethod
    def write(value, buf):
        if value >= datetime.datetime.fromtimestamp(0, datetime.timezone.utc):
            sign = 1
            delta = value - datetime.datetime.fromtimestamp(0, datetime.timezone.utc)
        else:
            sign = -1
            delta = datetime.datetime.fromtimestamp(0, datetime.timezone.utc) - value

        seconds = delta.seconds + delta.days * 24 * 3600
        nanoseconds = delta.microseconds * 1000
        buf.write_i64(sign * seconds)
        buf.write_u32(nanoseconds)


class Attachment:
    id: "typing.Optional[str]"
    url: "typing.Optional[str]"
    size: "typing.Optional[str]"
    size_name: "typing.Optional[str]"

    file_name: "typing.Optional[EncString]"
    key: "typing.Optional[EncString]"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[str]", url: "typing.Optional[str]", size: "typing.Optional[str]", size_name: "typing.Optional[str]", file_name: "typing.Optional[EncString]", key: "typing.Optional[EncString]"):
        self.id = id
        self.url = url
        self.size = size
        self.size_name = size_name
        self.file_name = file_name
        self.key = key

    def __str__(self):
        return "Attachment(id={}, url={}, size={}, size_name={}, file_name={}, key={})".format(self.id, self.url, self.size, self.size_name, self.file_name, self.key)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.url != other.url:
            return False
        if self.size != other.size:
            return False
        if self.size_name != other.size_name:
            return False
        if self.file_name != other.file_name:
            return False
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeAttachment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Attachment(
            id=_UniffiConverterOptionalString.read(buf),
            url=_UniffiConverterOptionalString.read(buf),
            size=_UniffiConverterOptionalString.read(buf),
            size_name=_UniffiConverterOptionalString.read(buf),
            file_name=_UniffiConverterOptionalTypeEncString.read(buf),
            key=_UniffiConverterOptionalTypeEncString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.url, buf)
        _UniffiConverterOptionalString.write(value.size, buf)
        _UniffiConverterOptionalString.write(value.size_name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.file_name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.key, buf)


class AttachmentView:
    id: "typing.Optional[str]"
    url: "typing.Optional[str]"
    size: "typing.Optional[str]"
    size_name: "typing.Optional[str]"
    file_name: "typing.Optional[str]"
    key: "typing.Optional[EncString]"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[str]", url: "typing.Optional[str]", size: "typing.Optional[str]", size_name: "typing.Optional[str]", file_name: "typing.Optional[str]", key: "typing.Optional[EncString]"):
        self.id = id
        self.url = url
        self.size = size
        self.size_name = size_name
        self.file_name = file_name
        self.key = key

    def __str__(self):
        return "AttachmentView(id={}, url={}, size={}, size_name={}, file_name={}, key={})".format(self.id, self.url, self.size, self.size_name, self.file_name, self.key)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.url != other.url:
            return False
        if self.size != other.size:
            return False
        if self.size_name != other.size_name:
            return False
        if self.file_name != other.file_name:
            return False
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeAttachmentView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AttachmentView(
            id=_UniffiConverterOptionalString.read(buf),
            url=_UniffiConverterOptionalString.read(buf),
            size=_UniffiConverterOptionalString.read(buf),
            size_name=_UniffiConverterOptionalString.read(buf),
            file_name=_UniffiConverterOptionalString.read(buf),
            key=_UniffiConverterOptionalTypeEncString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.url, buf)
        _UniffiConverterOptionalString.write(value.size, buf)
        _UniffiConverterOptionalString.write(value.size_name, buf)
        _UniffiConverterOptionalString.write(value.file_name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.key, buf)


class Card:
    cardholder_name: "typing.Optional[EncString]"
    exp_month: "typing.Optional[EncString]"
    exp_year: "typing.Optional[EncString]"
    code: "typing.Optional[EncString]"
    brand: "typing.Optional[EncString]"
    number: "typing.Optional[EncString]"
    @typing.no_type_check
    def __init__(self, cardholder_name: "typing.Optional[EncString]", exp_month: "typing.Optional[EncString]", exp_year: "typing.Optional[EncString]", code: "typing.Optional[EncString]", brand: "typing.Optional[EncString]", number: "typing.Optional[EncString]"):
        self.cardholder_name = cardholder_name
        self.exp_month = exp_month
        self.exp_year = exp_year
        self.code = code
        self.brand = brand
        self.number = number

    def __str__(self):
        return "Card(cardholder_name={}, exp_month={}, exp_year={}, code={}, brand={}, number={})".format(self.cardholder_name, self.exp_month, self.exp_year, self.code, self.brand, self.number)

    def __eq__(self, other):
        if self.cardholder_name != other.cardholder_name:
            return False
        if self.exp_month != other.exp_month:
            return False
        if self.exp_year != other.exp_year:
            return False
        if self.code != other.code:
            return False
        if self.brand != other.brand:
            return False
        if self.number != other.number:
            return False
        return True

class _UniffiConverterTypeCard(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Card(
            cardholder_name=_UniffiConverterOptionalTypeEncString.read(buf),
            exp_month=_UniffiConverterOptionalTypeEncString.read(buf),
            exp_year=_UniffiConverterOptionalTypeEncString.read(buf),
            code=_UniffiConverterOptionalTypeEncString.read(buf),
            brand=_UniffiConverterOptionalTypeEncString.read(buf),
            number=_UniffiConverterOptionalTypeEncString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeEncString.write(value.cardholder_name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.exp_month, buf)
        _UniffiConverterOptionalTypeEncString.write(value.exp_year, buf)
        _UniffiConverterOptionalTypeEncString.write(value.code, buf)
        _UniffiConverterOptionalTypeEncString.write(value.brand, buf)
        _UniffiConverterOptionalTypeEncString.write(value.number, buf)


class CardView:
    cardholder_name: "typing.Optional[str]"
    exp_month: "typing.Optional[str]"
    exp_year: "typing.Optional[str]"
    code: "typing.Optional[str]"
    brand: "typing.Optional[str]"
    number: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, cardholder_name: "typing.Optional[str]", exp_month: "typing.Optional[str]", exp_year: "typing.Optional[str]", code: "typing.Optional[str]", brand: "typing.Optional[str]", number: "typing.Optional[str]"):
        self.cardholder_name = cardholder_name
        self.exp_month = exp_month
        self.exp_year = exp_year
        self.code = code
        self.brand = brand
        self.number = number

    def __str__(self):
        return "CardView(cardholder_name={}, exp_month={}, exp_year={}, code={}, brand={}, number={})".format(self.cardholder_name, self.exp_month, self.exp_year, self.code, self.brand, self.number)

    def __eq__(self, other):
        if self.cardholder_name != other.cardholder_name:
            return False
        if self.exp_month != other.exp_month:
            return False
        if self.exp_year != other.exp_year:
            return False
        if self.code != other.code:
            return False
        if self.brand != other.brand:
            return False
        if self.number != other.number:
            return False
        return True

class _UniffiConverterTypeCardView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CardView(
            cardholder_name=_UniffiConverterOptionalString.read(buf),
            exp_month=_UniffiConverterOptionalString.read(buf),
            exp_year=_UniffiConverterOptionalString.read(buf),
            code=_UniffiConverterOptionalString.read(buf),
            brand=_UniffiConverterOptionalString.read(buf),
            number=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.cardholder_name, buf)
        _UniffiConverterOptionalString.write(value.exp_month, buf)
        _UniffiConverterOptionalString.write(value.exp_year, buf)
        _UniffiConverterOptionalString.write(value.code, buf)
        _UniffiConverterOptionalString.write(value.brand, buf)
        _UniffiConverterOptionalString.write(value.number, buf)


class Cipher:
    id: "typing.Optional[Uuid]"
    organization_id: "typing.Optional[Uuid]"
    folder_id: "typing.Optional[Uuid]"
    collection_ids: "typing.List[Uuid]"
    key: "typing.Optional[EncString]"
    """More recent ciphers uses individual encryption keys to encrypt the other fields of the Cipher."""

    name: "EncString"
    notes: "typing.Optional[EncString]"
    type: "CipherType"
    login: "typing.Optional[Login]"
    identity: "typing.Optional[Identity]"
    card: "typing.Optional[Card]"
    secure_note: "typing.Optional[SecureNote]"
    favorite: "bool"
    reprompt: "CipherRepromptType"
    organization_use_totp: "bool"
    edit: "bool"
    view_password: "bool"
    local_data: "typing.Optional[LocalData]"
    attachments: "typing.Optional[typing.List[Attachment]]"
    fields: "typing.Optional[typing.List[Field]]"
    password_history: "typing.Optional[typing.List[PasswordHistory]]"
    creation_date: "DateTime"
    deleted_date: "typing.Optional[DateTime]"
    revision_date: "DateTime"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", organization_id: "typing.Optional[Uuid]", folder_id: "typing.Optional[Uuid]", collection_ids: "typing.List[Uuid]", key: "typing.Optional[EncString]", name: "EncString", notes: "typing.Optional[EncString]", type: "CipherType", login: "typing.Optional[Login]", identity: "typing.Optional[Identity]", card: "typing.Optional[Card]", secure_note: "typing.Optional[SecureNote]", favorite: "bool", reprompt: "CipherRepromptType", organization_use_totp: "bool", edit: "bool", view_password: "bool", local_data: "typing.Optional[LocalData]", attachments: "typing.Optional[typing.List[Attachment]]", fields: "typing.Optional[typing.List[Field]]", password_history: "typing.Optional[typing.List[PasswordHistory]]", creation_date: "DateTime", deleted_date: "typing.Optional[DateTime]", revision_date: "DateTime"):
        self.id = id
        self.organization_id = organization_id
        self.folder_id = folder_id
        self.collection_ids = collection_ids
        self.key = key
        self.name = name
        self.notes = notes
        self.type = type
        self.login = login
        self.identity = identity
        self.card = card
        self.secure_note = secure_note
        self.favorite = favorite
        self.reprompt = reprompt
        self.organization_use_totp = organization_use_totp
        self.edit = edit
        self.view_password = view_password
        self.local_data = local_data
        self.attachments = attachments
        self.fields = fields
        self.password_history = password_history
        self.creation_date = creation_date
        self.deleted_date = deleted_date
        self.revision_date = revision_date

    def __str__(self):
        return "Cipher(id={}, organization_id={}, folder_id={}, collection_ids={}, key={}, name={}, notes={}, type={}, login={}, identity={}, card={}, secure_note={}, favorite={}, reprompt={}, organization_use_totp={}, edit={}, view_password={}, local_data={}, attachments={}, fields={}, password_history={}, creation_date={}, deleted_date={}, revision_date={})".format(self.id, self.organization_id, self.folder_id, self.collection_ids, self.key, self.name, self.notes, self.type, self.login, self.identity, self.card, self.secure_note, self.favorite, self.reprompt, self.organization_use_totp, self.edit, self.view_password, self.local_data, self.attachments, self.fields, self.password_history, self.creation_date, self.deleted_date, self.revision_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.organization_id != other.organization_id:
            return False
        if self.folder_id != other.folder_id:
            return False
        if self.collection_ids != other.collection_ids:
            return False
        if self.key != other.key:
            return False
        if self.name != other.name:
            return False
        if self.notes != other.notes:
            return False
        if self.type != other.type:
            return False
        if self.login != other.login:
            return False
        if self.identity != other.identity:
            return False
        if self.card != other.card:
            return False
        if self.secure_note != other.secure_note:
            return False
        if self.favorite != other.favorite:
            return False
        if self.reprompt != other.reprompt:
            return False
        if self.organization_use_totp != other.organization_use_totp:
            return False
        if self.edit != other.edit:
            return False
        if self.view_password != other.view_password:
            return False
        if self.local_data != other.local_data:
            return False
        if self.attachments != other.attachments:
            return False
        if self.fields != other.fields:
            return False
        if self.password_history != other.password_history:
            return False
        if self.creation_date != other.creation_date:
            return False
        if self.deleted_date != other.deleted_date:
            return False
        if self.revision_date != other.revision_date:
            return False
        return True

class _UniffiConverterTypeCipher(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Cipher(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            organization_id=_UniffiConverterOptionalTypeUuid.read(buf),
            folder_id=_UniffiConverterOptionalTypeUuid.read(buf),
            collection_ids=_UniffiConverterSequenceTypeUuid.read(buf),
            key=_UniffiConverterOptionalTypeEncString.read(buf),
            name=_UniffiConverterTypeEncString.read(buf),
            notes=_UniffiConverterOptionalTypeEncString.read(buf),
            type=_UniffiConverterTypeCipherType.read(buf),
            login=_UniffiConverterOptionalTypeLogin.read(buf),
            identity=_UniffiConverterOptionalTypeIdentity.read(buf),
            card=_UniffiConverterOptionalTypeCard.read(buf),
            secure_note=_UniffiConverterOptionalTypeSecureNote.read(buf),
            favorite=_UniffiConverterBool.read(buf),
            reprompt=_UniffiConverterTypeCipherRepromptType.read(buf),
            organization_use_totp=_UniffiConverterBool.read(buf),
            edit=_UniffiConverterBool.read(buf),
            view_password=_UniffiConverterBool.read(buf),
            local_data=_UniffiConverterOptionalTypeLocalData.read(buf),
            attachments=_UniffiConverterOptionalSequenceTypeAttachment.read(buf),
            fields=_UniffiConverterOptionalSequenceTypeField.read(buf),
            password_history=_UniffiConverterOptionalSequenceTypePasswordHistory.read(buf),
            creation_date=_UniffiConverterTypeDateTime.read(buf),
            deleted_date=_UniffiConverterOptionalTypeDateTime.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterOptionalTypeUuid.write(value.organization_id, buf)
        _UniffiConverterOptionalTypeUuid.write(value.folder_id, buf)
        _UniffiConverterSequenceTypeUuid.write(value.collection_ids, buf)
        _UniffiConverterOptionalTypeEncString.write(value.key, buf)
        _UniffiConverterTypeEncString.write(value.name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.notes, buf)
        _UniffiConverterTypeCipherType.write(value.type, buf)
        _UniffiConverterOptionalTypeLogin.write(value.login, buf)
        _UniffiConverterOptionalTypeIdentity.write(value.identity, buf)
        _UniffiConverterOptionalTypeCard.write(value.card, buf)
        _UniffiConverterOptionalTypeSecureNote.write(value.secure_note, buf)
        _UniffiConverterBool.write(value.favorite, buf)
        _UniffiConverterTypeCipherRepromptType.write(value.reprompt, buf)
        _UniffiConverterBool.write(value.organization_use_totp, buf)
        _UniffiConverterBool.write(value.edit, buf)
        _UniffiConverterBool.write(value.view_password, buf)
        _UniffiConverterOptionalTypeLocalData.write(value.local_data, buf)
        _UniffiConverterOptionalSequenceTypeAttachment.write(value.attachments, buf)
        _UniffiConverterOptionalSequenceTypeField.write(value.fields, buf)
        _UniffiConverterOptionalSequenceTypePasswordHistory.write(value.password_history, buf)
        _UniffiConverterTypeDateTime.write(value.creation_date, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.deleted_date, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)


class CipherListView:
    id: "typing.Optional[Uuid]"
    organization_id: "typing.Optional[Uuid]"
    folder_id: "typing.Optional[Uuid]"
    collection_ids: "typing.List[Uuid]"
    name: "str"
    sub_title: "str"
    type: "CipherType"
    favorite: "bool"
    reprompt: "CipherRepromptType"
    edit: "bool"
    view_password: "bool"
    attachments: "int"
    """The number of attachments"""

    creation_date: "DateTime"
    deleted_date: "typing.Optional[DateTime]"
    revision_date: "DateTime"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", organization_id: "typing.Optional[Uuid]", folder_id: "typing.Optional[Uuid]", collection_ids: "typing.List[Uuid]", name: "str", sub_title: "str", type: "CipherType", favorite: "bool", reprompt: "CipherRepromptType", edit: "bool", view_password: "bool", attachments: "int", creation_date: "DateTime", deleted_date: "typing.Optional[DateTime]", revision_date: "DateTime"):
        self.id = id
        self.organization_id = organization_id
        self.folder_id = folder_id
        self.collection_ids = collection_ids
        self.name = name
        self.sub_title = sub_title
        self.type = type
        self.favorite = favorite
        self.reprompt = reprompt
        self.edit = edit
        self.view_password = view_password
        self.attachments = attachments
        self.creation_date = creation_date
        self.deleted_date = deleted_date
        self.revision_date = revision_date

    def __str__(self):
        return "CipherListView(id={}, organization_id={}, folder_id={}, collection_ids={}, name={}, sub_title={}, type={}, favorite={}, reprompt={}, edit={}, view_password={}, attachments={}, creation_date={}, deleted_date={}, revision_date={})".format(self.id, self.organization_id, self.folder_id, self.collection_ids, self.name, self.sub_title, self.type, self.favorite, self.reprompt, self.edit, self.view_password, self.attachments, self.creation_date, self.deleted_date, self.revision_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.organization_id != other.organization_id:
            return False
        if self.folder_id != other.folder_id:
            return False
        if self.collection_ids != other.collection_ids:
            return False
        if self.name != other.name:
            return False
        if self.sub_title != other.sub_title:
            return False
        if self.type != other.type:
            return False
        if self.favorite != other.favorite:
            return False
        if self.reprompt != other.reprompt:
            return False
        if self.edit != other.edit:
            return False
        if self.view_password != other.view_password:
            return False
        if self.attachments != other.attachments:
            return False
        if self.creation_date != other.creation_date:
            return False
        if self.deleted_date != other.deleted_date:
            return False
        if self.revision_date != other.revision_date:
            return False
        return True

class _UniffiConverterTypeCipherListView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CipherListView(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            organization_id=_UniffiConverterOptionalTypeUuid.read(buf),
            folder_id=_UniffiConverterOptionalTypeUuid.read(buf),
            collection_ids=_UniffiConverterSequenceTypeUuid.read(buf),
            name=_UniffiConverterString.read(buf),
            sub_title=_UniffiConverterString.read(buf),
            type=_UniffiConverterTypeCipherType.read(buf),
            favorite=_UniffiConverterBool.read(buf),
            reprompt=_UniffiConverterTypeCipherRepromptType.read(buf),
            edit=_UniffiConverterBool.read(buf),
            view_password=_UniffiConverterBool.read(buf),
            attachments=_UniffiConverterUInt32.read(buf),
            creation_date=_UniffiConverterTypeDateTime.read(buf),
            deleted_date=_UniffiConverterOptionalTypeDateTime.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterOptionalTypeUuid.write(value.organization_id, buf)
        _UniffiConverterOptionalTypeUuid.write(value.folder_id, buf)
        _UniffiConverterSequenceTypeUuid.write(value.collection_ids, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterString.write(value.sub_title, buf)
        _UniffiConverterTypeCipherType.write(value.type, buf)
        _UniffiConverterBool.write(value.favorite, buf)
        _UniffiConverterTypeCipherRepromptType.write(value.reprompt, buf)
        _UniffiConverterBool.write(value.edit, buf)
        _UniffiConverterBool.write(value.view_password, buf)
        _UniffiConverterUInt32.write(value.attachments, buf)
        _UniffiConverterTypeDateTime.write(value.creation_date, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.deleted_date, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)


class CipherView:
    id: "typing.Optional[Uuid]"
    organization_id: "typing.Optional[Uuid]"
    folder_id: "typing.Optional[Uuid]"
    collection_ids: "typing.List[Uuid]"
    key: "typing.Optional[EncString]"
    name: "str"
    notes: "typing.Optional[str]"
    type: "CipherType"
    login: "typing.Optional[LoginView]"
    identity: "typing.Optional[IdentityView]"
    card: "typing.Optional[CardView]"
    secure_note: "typing.Optional[SecureNoteView]"
    favorite: "bool"
    reprompt: "CipherRepromptType"
    organization_use_totp: "bool"
    edit: "bool"
    view_password: "bool"
    local_data: "typing.Optional[LocalDataView]"
    attachments: "typing.Optional[typing.List[AttachmentView]]"
    fields: "typing.Optional[typing.List[FieldView]]"
    password_history: "typing.Optional[typing.List[PasswordHistoryView]]"
    creation_date: "DateTime"
    deleted_date: "typing.Optional[DateTime]"
    revision_date: "DateTime"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", organization_id: "typing.Optional[Uuid]", folder_id: "typing.Optional[Uuid]", collection_ids: "typing.List[Uuid]", key: "typing.Optional[EncString]", name: "str", notes: "typing.Optional[str]", type: "CipherType", login: "typing.Optional[LoginView]", identity: "typing.Optional[IdentityView]", card: "typing.Optional[CardView]", secure_note: "typing.Optional[SecureNoteView]", favorite: "bool", reprompt: "CipherRepromptType", organization_use_totp: "bool", edit: "bool", view_password: "bool", local_data: "typing.Optional[LocalDataView]", attachments: "typing.Optional[typing.List[AttachmentView]]", fields: "typing.Optional[typing.List[FieldView]]", password_history: "typing.Optional[typing.List[PasswordHistoryView]]", creation_date: "DateTime", deleted_date: "typing.Optional[DateTime]", revision_date: "DateTime"):
        self.id = id
        self.organization_id = organization_id
        self.folder_id = folder_id
        self.collection_ids = collection_ids
        self.key = key
        self.name = name
        self.notes = notes
        self.type = type
        self.login = login
        self.identity = identity
        self.card = card
        self.secure_note = secure_note
        self.favorite = favorite
        self.reprompt = reprompt
        self.organization_use_totp = organization_use_totp
        self.edit = edit
        self.view_password = view_password
        self.local_data = local_data
        self.attachments = attachments
        self.fields = fields
        self.password_history = password_history
        self.creation_date = creation_date
        self.deleted_date = deleted_date
        self.revision_date = revision_date

    def __str__(self):
        return "CipherView(id={}, organization_id={}, folder_id={}, collection_ids={}, key={}, name={}, notes={}, type={}, login={}, identity={}, card={}, secure_note={}, favorite={}, reprompt={}, organization_use_totp={}, edit={}, view_password={}, local_data={}, attachments={}, fields={}, password_history={}, creation_date={}, deleted_date={}, revision_date={})".format(self.id, self.organization_id, self.folder_id, self.collection_ids, self.key, self.name, self.notes, self.type, self.login, self.identity, self.card, self.secure_note, self.favorite, self.reprompt, self.organization_use_totp, self.edit, self.view_password, self.local_data, self.attachments, self.fields, self.password_history, self.creation_date, self.deleted_date, self.revision_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.organization_id != other.organization_id:
            return False
        if self.folder_id != other.folder_id:
            return False
        if self.collection_ids != other.collection_ids:
            return False
        if self.key != other.key:
            return False
        if self.name != other.name:
            return False
        if self.notes != other.notes:
            return False
        if self.type != other.type:
            return False
        if self.login != other.login:
            return False
        if self.identity != other.identity:
            return False
        if self.card != other.card:
            return False
        if self.secure_note != other.secure_note:
            return False
        if self.favorite != other.favorite:
            return False
        if self.reprompt != other.reprompt:
            return False
        if self.organization_use_totp != other.organization_use_totp:
            return False
        if self.edit != other.edit:
            return False
        if self.view_password != other.view_password:
            return False
        if self.local_data != other.local_data:
            return False
        if self.attachments != other.attachments:
            return False
        if self.fields != other.fields:
            return False
        if self.password_history != other.password_history:
            return False
        if self.creation_date != other.creation_date:
            return False
        if self.deleted_date != other.deleted_date:
            return False
        if self.revision_date != other.revision_date:
            return False
        return True

class _UniffiConverterTypeCipherView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CipherView(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            organization_id=_UniffiConverterOptionalTypeUuid.read(buf),
            folder_id=_UniffiConverterOptionalTypeUuid.read(buf),
            collection_ids=_UniffiConverterSequenceTypeUuid.read(buf),
            key=_UniffiConverterOptionalTypeEncString.read(buf),
            name=_UniffiConverterString.read(buf),
            notes=_UniffiConverterOptionalString.read(buf),
            type=_UniffiConverterTypeCipherType.read(buf),
            login=_UniffiConverterOptionalTypeLoginView.read(buf),
            identity=_UniffiConverterOptionalTypeIdentityView.read(buf),
            card=_UniffiConverterOptionalTypeCardView.read(buf),
            secure_note=_UniffiConverterOptionalTypeSecureNoteView.read(buf),
            favorite=_UniffiConverterBool.read(buf),
            reprompt=_UniffiConverterTypeCipherRepromptType.read(buf),
            organization_use_totp=_UniffiConverterBool.read(buf),
            edit=_UniffiConverterBool.read(buf),
            view_password=_UniffiConverterBool.read(buf),
            local_data=_UniffiConverterOptionalTypeLocalDataView.read(buf),
            attachments=_UniffiConverterOptionalSequenceTypeAttachmentView.read(buf),
            fields=_UniffiConverterOptionalSequenceTypeFieldView.read(buf),
            password_history=_UniffiConverterOptionalSequenceTypePasswordHistoryView.read(buf),
            creation_date=_UniffiConverterTypeDateTime.read(buf),
            deleted_date=_UniffiConverterOptionalTypeDateTime.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterOptionalTypeUuid.write(value.organization_id, buf)
        _UniffiConverterOptionalTypeUuid.write(value.folder_id, buf)
        _UniffiConverterSequenceTypeUuid.write(value.collection_ids, buf)
        _UniffiConverterOptionalTypeEncString.write(value.key, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.notes, buf)
        _UniffiConverterTypeCipherType.write(value.type, buf)
        _UniffiConverterOptionalTypeLoginView.write(value.login, buf)
        _UniffiConverterOptionalTypeIdentityView.write(value.identity, buf)
        _UniffiConverterOptionalTypeCardView.write(value.card, buf)
        _UniffiConverterOptionalTypeSecureNoteView.write(value.secure_note, buf)
        _UniffiConverterBool.write(value.favorite, buf)
        _UniffiConverterTypeCipherRepromptType.write(value.reprompt, buf)
        _UniffiConverterBool.write(value.organization_use_totp, buf)
        _UniffiConverterBool.write(value.edit, buf)
        _UniffiConverterBool.write(value.view_password, buf)
        _UniffiConverterOptionalTypeLocalDataView.write(value.local_data, buf)
        _UniffiConverterOptionalSequenceTypeAttachmentView.write(value.attachments, buf)
        _UniffiConverterOptionalSequenceTypeFieldView.write(value.fields, buf)
        _UniffiConverterOptionalSequenceTypePasswordHistoryView.write(value.password_history, buf)
        _UniffiConverterTypeDateTime.write(value.creation_date, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.deleted_date, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)


class ClientSettings:
    """
    Basic client behavior settings. These settings specify the various targets and behavior of the Bitwarden Client.
    They are optional and uneditable once the client is initialized.

    Defaults to

    ```
    # use bitwarden::client::client_settings::{ClientSettings, DeviceType};
    let settings = ClientSettings {
        identity_url: "https://identity.bitwarden.com".to_string(),
        api_url: "https://api.bitwarden.com".to_string(),
        user_agent: "Bitwarden Rust-SDK".to_string(),
        device_type: DeviceType::SDK,
    };
    let default = ClientSettings::default();
    ```
    """

    identity_url: "str"
    """The identity url of the targeted Bitwarden instance. Defaults to `https://identity.bitwarden.com`"""

    api_url: "str"
    """The api url of the targeted Bitwarden instance. Defaults to `https://api.bitwarden.com`"""

    user_agent: "str"
    """The user_agent to sent to Bitwarden. Defaults to `Bitwarden Rust-SDK`"""

    device_type: "DeviceType"
    """Device type to send to Bitwarden. Defaults to SDK"""

    @typing.no_type_check
    def __init__(self, identity_url: "str", api_url: "str", user_agent: "str", device_type: "DeviceType"):
        self.identity_url = identity_url
        self.api_url = api_url
        self.user_agent = user_agent
        self.device_type = device_type

    def __str__(self):
        return "ClientSettings(identity_url={}, api_url={}, user_agent={}, device_type={})".format(self.identity_url, self.api_url, self.user_agent, self.device_type)

    def __eq__(self, other):
        if self.identity_url != other.identity_url:
            return False
        if self.api_url != other.api_url:
            return False
        if self.user_agent != other.user_agent:
            return False
        if self.device_type != other.device_type:
            return False
        return True

class _UniffiConverterTypeClientSettings(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientSettings(
            identity_url=_UniffiConverterString.read(buf),
            api_url=_UniffiConverterString.read(buf),
            user_agent=_UniffiConverterString.read(buf),
            device_type=_UniffiConverterTypeDeviceType.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.identity_url, buf)
        _UniffiConverterString.write(value.api_url, buf)
        _UniffiConverterString.write(value.user_agent, buf)
        _UniffiConverterTypeDeviceType.write(value.device_type, buf)


class Collection:
    id: "typing.Optional[Uuid]"
    organization_id: "Uuid"
    name: "EncString"
    external_id: "typing.Optional[str]"
    hide_passwords: "bool"
    read_only: "bool"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", organization_id: "Uuid", name: "EncString", external_id: "typing.Optional[str]", hide_passwords: "bool", read_only: "bool"):
        self.id = id
        self.organization_id = organization_id
        self.name = name
        self.external_id = external_id
        self.hide_passwords = hide_passwords
        self.read_only = read_only

    def __str__(self):
        return "Collection(id={}, organization_id={}, name={}, external_id={}, hide_passwords={}, read_only={})".format(self.id, self.organization_id, self.name, self.external_id, self.hide_passwords, self.read_only)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.organization_id != other.organization_id:
            return False
        if self.name != other.name:
            return False
        if self.external_id != other.external_id:
            return False
        if self.hide_passwords != other.hide_passwords:
            return False
        if self.read_only != other.read_only:
            return False
        return True

class _UniffiConverterTypeCollection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Collection(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            organization_id=_UniffiConverterTypeUuid.read(buf),
            name=_UniffiConverterTypeEncString.read(buf),
            external_id=_UniffiConverterOptionalString.read(buf),
            hide_passwords=_UniffiConverterBool.read(buf),
            read_only=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterTypeUuid.write(value.organization_id, buf)
        _UniffiConverterTypeEncString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.external_id, buf)
        _UniffiConverterBool.write(value.hide_passwords, buf)
        _UniffiConverterBool.write(value.read_only, buf)


class CollectionView:
    id: "typing.Optional[Uuid]"
    organization_id: "Uuid"
    name: "str"
    external_id: "typing.Optional[str]"
    hide_passwords: "bool"
    read_only: "bool"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", organization_id: "Uuid", name: "str", external_id: "typing.Optional[str]", hide_passwords: "bool", read_only: "bool"):
        self.id = id
        self.organization_id = organization_id
        self.name = name
        self.external_id = external_id
        self.hide_passwords = hide_passwords
        self.read_only = read_only

    def __str__(self):
        return "CollectionView(id={}, organization_id={}, name={}, external_id={}, hide_passwords={}, read_only={})".format(self.id, self.organization_id, self.name, self.external_id, self.hide_passwords, self.read_only)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.organization_id != other.organization_id:
            return False
        if self.name != other.name:
            return False
        if self.external_id != other.external_id:
            return False
        if self.hide_passwords != other.hide_passwords:
            return False
        if self.read_only != other.read_only:
            return False
        return True

class _UniffiConverterTypeCollectionView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CollectionView(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            organization_id=_UniffiConverterTypeUuid.read(buf),
            name=_UniffiConverterString.read(buf),
            external_id=_UniffiConverterOptionalString.read(buf),
            hide_passwords=_UniffiConverterBool.read(buf),
            read_only=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterTypeUuid.write(value.organization_id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.external_id, buf)
        _UniffiConverterBool.write(value.hide_passwords, buf)
        _UniffiConverterBool.write(value.read_only, buf)


class DerivePinKeyResponse:
    pin_protected_user_key: "EncString"
    encrypted_pin: "EncString"
    @typing.no_type_check
    def __init__(self, pin_protected_user_key: "EncString", encrypted_pin: "EncString"):
        self.pin_protected_user_key = pin_protected_user_key
        self.encrypted_pin = encrypted_pin

    def __str__(self):
        return "DerivePinKeyResponse(pin_protected_user_key={}, encrypted_pin={})".format(self.pin_protected_user_key, self.encrypted_pin)

    def __eq__(self, other):
        if self.pin_protected_user_key != other.pin_protected_user_key:
            return False
        if self.encrypted_pin != other.encrypted_pin:
            return False
        return True

class _UniffiConverterTypeDerivePinKeyResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DerivePinKeyResponse(
            pin_protected_user_key=_UniffiConverterTypeEncString.read(buf),
            encrypted_pin=_UniffiConverterTypeEncString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncString.write(value.pin_protected_user_key, buf)
        _UniffiConverterTypeEncString.write(value.encrypted_pin, buf)


class Field:
    name: "typing.Optional[EncString]"
    value: "typing.Optional[EncString]"
    type: "FieldType"
    linked_id: "typing.Optional[LinkedIdType]"
    @typing.no_type_check
    def __init__(self, name: "typing.Optional[EncString]", value: "typing.Optional[EncString]", type: "FieldType", linked_id: "typing.Optional[LinkedIdType]"):
        self.name = name
        self.value = value
        self.type = type
        self.linked_id = linked_id

    def __str__(self):
        return "Field(name={}, value={}, type={}, linked_id={})".format(self.name, self.value, self.type, self.linked_id)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.value != other.value:
            return False
        if self.type != other.type:
            return False
        if self.linked_id != other.linked_id:
            return False
        return True

class _UniffiConverterTypeField(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Field(
            name=_UniffiConverterOptionalTypeEncString.read(buf),
            value=_UniffiConverterOptionalTypeEncString.read(buf),
            type=_UniffiConverterTypeFieldType.read(buf),
            linked_id=_UniffiConverterOptionalTypeLinkedIdType.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeEncString.write(value.name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.value, buf)
        _UniffiConverterTypeFieldType.write(value.type, buf)
        _UniffiConverterOptionalTypeLinkedIdType.write(value.linked_id, buf)


class FieldView:
    name: "typing.Optional[str]"
    value: "typing.Optional[str]"
    type: "FieldType"
    linked_id: "typing.Optional[LinkedIdType]"
    @typing.no_type_check
    def __init__(self, name: "typing.Optional[str]", value: "typing.Optional[str]", type: "FieldType", linked_id: "typing.Optional[LinkedIdType]"):
        self.name = name
        self.value = value
        self.type = type
        self.linked_id = linked_id

    def __str__(self):
        return "FieldView(name={}, value={}, type={}, linked_id={})".format(self.name, self.value, self.type, self.linked_id)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.value != other.value:
            return False
        if self.type != other.type:
            return False
        if self.linked_id != other.linked_id:
            return False
        return True

class _UniffiConverterTypeFieldView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FieldView(
            name=_UniffiConverterOptionalString.read(buf),
            value=_UniffiConverterOptionalString.read(buf),
            type=_UniffiConverterTypeFieldType.read(buf),
            linked_id=_UniffiConverterOptionalTypeLinkedIdType.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.value, buf)
        _UniffiConverterTypeFieldType.write(value.type, buf)
        _UniffiConverterOptionalTypeLinkedIdType.write(value.linked_id, buf)


class FingerprintRequest:
    fingerprint_material: "str"
    """The input material, used in the fingerprint generation process."""

    public_key: "str"
    """The user's public key encoded with base64."""

    @typing.no_type_check
    def __init__(self, fingerprint_material: "str", public_key: "str"):
        self.fingerprint_material = fingerprint_material
        self.public_key = public_key

    def __str__(self):
        return "FingerprintRequest(fingerprint_material={}, public_key={})".format(self.fingerprint_material, self.public_key)

    def __eq__(self, other):
        if self.fingerprint_material != other.fingerprint_material:
            return False
        if self.public_key != other.public_key:
            return False
        return True

class _UniffiConverterTypeFingerprintRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FingerprintRequest(
            fingerprint_material=_UniffiConverterString.read(buf),
            public_key=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.fingerprint_material, buf)
        _UniffiConverterString.write(value.public_key, buf)


class Folder:
    id: "typing.Optional[Uuid]"
    name: "EncString"
    revision_date: "DateTime"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", name: "EncString", revision_date: "DateTime"):
        self.id = id
        self.name = name
        self.revision_date = revision_date

    def __str__(self):
        return "Folder(id={}, name={}, revision_date={})".format(self.id, self.name, self.revision_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.revision_date != other.revision_date:
            return False
        return True

class _UniffiConverterTypeFolder(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Folder(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            name=_UniffiConverterTypeEncString.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterTypeEncString.write(value.name, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)


class FolderView:
    id: "typing.Optional[Uuid]"
    name: "str"
    revision_date: "DateTime"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", name: "str", revision_date: "DateTime"):
        self.id = id
        self.name = name
        self.revision_date = revision_date

    def __str__(self):
        return "FolderView(id={}, name={}, revision_date={})".format(self.id, self.name, self.revision_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.revision_date != other.revision_date:
            return False
        return True

class _UniffiConverterTypeFolderView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FolderView(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            name=_UniffiConverterString.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)


class Identity:
    title: "typing.Optional[EncString]"
    first_name: "typing.Optional[EncString]"
    middle_name: "typing.Optional[EncString]"
    last_name: "typing.Optional[EncString]"
    address1: "typing.Optional[EncString]"
    address2: "typing.Optional[EncString]"
    address3: "typing.Optional[EncString]"
    city: "typing.Optional[EncString]"
    state: "typing.Optional[EncString]"
    postal_code: "typing.Optional[EncString]"
    country: "typing.Optional[EncString]"
    company: "typing.Optional[EncString]"
    email: "typing.Optional[EncString]"
    phone: "typing.Optional[EncString]"
    ssn: "typing.Optional[EncString]"
    username: "typing.Optional[EncString]"
    passport_number: "typing.Optional[EncString]"
    license_number: "typing.Optional[EncString]"
    @typing.no_type_check
    def __init__(self, title: "typing.Optional[EncString]", first_name: "typing.Optional[EncString]", middle_name: "typing.Optional[EncString]", last_name: "typing.Optional[EncString]", address1: "typing.Optional[EncString]", address2: "typing.Optional[EncString]", address3: "typing.Optional[EncString]", city: "typing.Optional[EncString]", state: "typing.Optional[EncString]", postal_code: "typing.Optional[EncString]", country: "typing.Optional[EncString]", company: "typing.Optional[EncString]", email: "typing.Optional[EncString]", phone: "typing.Optional[EncString]", ssn: "typing.Optional[EncString]", username: "typing.Optional[EncString]", passport_number: "typing.Optional[EncString]", license_number: "typing.Optional[EncString]"):
        self.title = title
        self.first_name = first_name
        self.middle_name = middle_name
        self.last_name = last_name
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.city = city
        self.state = state
        self.postal_code = postal_code
        self.country = country
        self.company = company
        self.email = email
        self.phone = phone
        self.ssn = ssn
        self.username = username
        self.passport_number = passport_number
        self.license_number = license_number

    def __str__(self):
        return "Identity(title={}, first_name={}, middle_name={}, last_name={}, address1={}, address2={}, address3={}, city={}, state={}, postal_code={}, country={}, company={}, email={}, phone={}, ssn={}, username={}, passport_number={}, license_number={})".format(self.title, self.first_name, self.middle_name, self.last_name, self.address1, self.address2, self.address3, self.city, self.state, self.postal_code, self.country, self.company, self.email, self.phone, self.ssn, self.username, self.passport_number, self.license_number)

    def __eq__(self, other):
        if self.title != other.title:
            return False
        if self.first_name != other.first_name:
            return False
        if self.middle_name != other.middle_name:
            return False
        if self.last_name != other.last_name:
            return False
        if self.address1 != other.address1:
            return False
        if self.address2 != other.address2:
            return False
        if self.address3 != other.address3:
            return False
        if self.city != other.city:
            return False
        if self.state != other.state:
            return False
        if self.postal_code != other.postal_code:
            return False
        if self.country != other.country:
            return False
        if self.company != other.company:
            return False
        if self.email != other.email:
            return False
        if self.phone != other.phone:
            return False
        if self.ssn != other.ssn:
            return False
        if self.username != other.username:
            return False
        if self.passport_number != other.passport_number:
            return False
        if self.license_number != other.license_number:
            return False
        return True

class _UniffiConverterTypeIdentity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Identity(
            title=_UniffiConverterOptionalTypeEncString.read(buf),
            first_name=_UniffiConverterOptionalTypeEncString.read(buf),
            middle_name=_UniffiConverterOptionalTypeEncString.read(buf),
            last_name=_UniffiConverterOptionalTypeEncString.read(buf),
            address1=_UniffiConverterOptionalTypeEncString.read(buf),
            address2=_UniffiConverterOptionalTypeEncString.read(buf),
            address3=_UniffiConverterOptionalTypeEncString.read(buf),
            city=_UniffiConverterOptionalTypeEncString.read(buf),
            state=_UniffiConverterOptionalTypeEncString.read(buf),
            postal_code=_UniffiConverterOptionalTypeEncString.read(buf),
            country=_UniffiConverterOptionalTypeEncString.read(buf),
            company=_UniffiConverterOptionalTypeEncString.read(buf),
            email=_UniffiConverterOptionalTypeEncString.read(buf),
            phone=_UniffiConverterOptionalTypeEncString.read(buf),
            ssn=_UniffiConverterOptionalTypeEncString.read(buf),
            username=_UniffiConverterOptionalTypeEncString.read(buf),
            passport_number=_UniffiConverterOptionalTypeEncString.read(buf),
            license_number=_UniffiConverterOptionalTypeEncString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeEncString.write(value.title, buf)
        _UniffiConverterOptionalTypeEncString.write(value.first_name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.middle_name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.last_name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.address1, buf)
        _UniffiConverterOptionalTypeEncString.write(value.address2, buf)
        _UniffiConverterOptionalTypeEncString.write(value.address3, buf)
        _UniffiConverterOptionalTypeEncString.write(value.city, buf)
        _UniffiConverterOptionalTypeEncString.write(value.state, buf)
        _UniffiConverterOptionalTypeEncString.write(value.postal_code, buf)
        _UniffiConverterOptionalTypeEncString.write(value.country, buf)
        _UniffiConverterOptionalTypeEncString.write(value.company, buf)
        _UniffiConverterOptionalTypeEncString.write(value.email, buf)
        _UniffiConverterOptionalTypeEncString.write(value.phone, buf)
        _UniffiConverterOptionalTypeEncString.write(value.ssn, buf)
        _UniffiConverterOptionalTypeEncString.write(value.username, buf)
        _UniffiConverterOptionalTypeEncString.write(value.passport_number, buf)
        _UniffiConverterOptionalTypeEncString.write(value.license_number, buf)


class IdentityView:
    title: "typing.Optional[str]"
    first_name: "typing.Optional[str]"
    middle_name: "typing.Optional[str]"
    last_name: "typing.Optional[str]"
    address1: "typing.Optional[str]"
    address2: "typing.Optional[str]"
    address3: "typing.Optional[str]"
    city: "typing.Optional[str]"
    state: "typing.Optional[str]"
    postal_code: "typing.Optional[str]"
    country: "typing.Optional[str]"
    company: "typing.Optional[str]"
    email: "typing.Optional[str]"
    phone: "typing.Optional[str]"
    ssn: "typing.Optional[str]"
    username: "typing.Optional[str]"
    passport_number: "typing.Optional[str]"
    license_number: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, title: "typing.Optional[str]", first_name: "typing.Optional[str]", middle_name: "typing.Optional[str]", last_name: "typing.Optional[str]", address1: "typing.Optional[str]", address2: "typing.Optional[str]", address3: "typing.Optional[str]", city: "typing.Optional[str]", state: "typing.Optional[str]", postal_code: "typing.Optional[str]", country: "typing.Optional[str]", company: "typing.Optional[str]", email: "typing.Optional[str]", phone: "typing.Optional[str]", ssn: "typing.Optional[str]", username: "typing.Optional[str]", passport_number: "typing.Optional[str]", license_number: "typing.Optional[str]"):
        self.title = title
        self.first_name = first_name
        self.middle_name = middle_name
        self.last_name = last_name
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.city = city
        self.state = state
        self.postal_code = postal_code
        self.country = country
        self.company = company
        self.email = email
        self.phone = phone
        self.ssn = ssn
        self.username = username
        self.passport_number = passport_number
        self.license_number = license_number

    def __str__(self):
        return "IdentityView(title={}, first_name={}, middle_name={}, last_name={}, address1={}, address2={}, address3={}, city={}, state={}, postal_code={}, country={}, company={}, email={}, phone={}, ssn={}, username={}, passport_number={}, license_number={})".format(self.title, self.first_name, self.middle_name, self.last_name, self.address1, self.address2, self.address3, self.city, self.state, self.postal_code, self.country, self.company, self.email, self.phone, self.ssn, self.username, self.passport_number, self.license_number)

    def __eq__(self, other):
        if self.title != other.title:
            return False
        if self.first_name != other.first_name:
            return False
        if self.middle_name != other.middle_name:
            return False
        if self.last_name != other.last_name:
            return False
        if self.address1 != other.address1:
            return False
        if self.address2 != other.address2:
            return False
        if self.address3 != other.address3:
            return False
        if self.city != other.city:
            return False
        if self.state != other.state:
            return False
        if self.postal_code != other.postal_code:
            return False
        if self.country != other.country:
            return False
        if self.company != other.company:
            return False
        if self.email != other.email:
            return False
        if self.phone != other.phone:
            return False
        if self.ssn != other.ssn:
            return False
        if self.username != other.username:
            return False
        if self.passport_number != other.passport_number:
            return False
        if self.license_number != other.license_number:
            return False
        return True

class _UniffiConverterTypeIdentityView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IdentityView(
            title=_UniffiConverterOptionalString.read(buf),
            first_name=_UniffiConverterOptionalString.read(buf),
            middle_name=_UniffiConverterOptionalString.read(buf),
            last_name=_UniffiConverterOptionalString.read(buf),
            address1=_UniffiConverterOptionalString.read(buf),
            address2=_UniffiConverterOptionalString.read(buf),
            address3=_UniffiConverterOptionalString.read(buf),
            city=_UniffiConverterOptionalString.read(buf),
            state=_UniffiConverterOptionalString.read(buf),
            postal_code=_UniffiConverterOptionalString.read(buf),
            country=_UniffiConverterOptionalString.read(buf),
            company=_UniffiConverterOptionalString.read(buf),
            email=_UniffiConverterOptionalString.read(buf),
            phone=_UniffiConverterOptionalString.read(buf),
            ssn=_UniffiConverterOptionalString.read(buf),
            username=_UniffiConverterOptionalString.read(buf),
            passport_number=_UniffiConverterOptionalString.read(buf),
            license_number=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.title, buf)
        _UniffiConverterOptionalString.write(value.first_name, buf)
        _UniffiConverterOptionalString.write(value.middle_name, buf)
        _UniffiConverterOptionalString.write(value.last_name, buf)
        _UniffiConverterOptionalString.write(value.address1, buf)
        _UniffiConverterOptionalString.write(value.address2, buf)
        _UniffiConverterOptionalString.write(value.address3, buf)
        _UniffiConverterOptionalString.write(value.city, buf)
        _UniffiConverterOptionalString.write(value.state, buf)
        _UniffiConverterOptionalString.write(value.postal_code, buf)
        _UniffiConverterOptionalString.write(value.country, buf)
        _UniffiConverterOptionalString.write(value.company, buf)
        _UniffiConverterOptionalString.write(value.email, buf)
        _UniffiConverterOptionalString.write(value.phone, buf)
        _UniffiConverterOptionalString.write(value.ssn, buf)
        _UniffiConverterOptionalString.write(value.username, buf)
        _UniffiConverterOptionalString.write(value.passport_number, buf)
        _UniffiConverterOptionalString.write(value.license_number, buf)


class InitOrgCryptoRequest:
    organization_keys: "dict"
    """The encryption keys for all the organizations the user is a part of"""

    @typing.no_type_check
    def __init__(self, organization_keys: "dict"):
        self.organization_keys = organization_keys

    def __str__(self):
        return "InitOrgCryptoRequest(organization_keys={})".format(self.organization_keys)

    def __eq__(self, other):
        if self.organization_keys != other.organization_keys:
            return False
        return True

class _UniffiConverterTypeInitOrgCryptoRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InitOrgCryptoRequest(
            organization_keys=_UniffiConverterMapTypeUuidTypeAsymmEncString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeUuidTypeAsymmEncString.write(value.organization_keys, buf)


class InitUserCryptoRequest:
    kdf_params: "Kdf"
    """The user's KDF parameters, as received from the prelogin request"""

    email: "str"
    """The user's email address"""

    private_key: "str"
    """The user's encrypted private key"""

    method: "InitUserCryptoMethod"
    """The initialization method to use"""

    @typing.no_type_check
    def __init__(self, kdf_params: "Kdf", email: "str", private_key: "str", method: "InitUserCryptoMethod"):
        self.kdf_params = kdf_params
        self.email = email
        self.private_key = private_key
        self.method = method

    def __str__(self):
        return "InitUserCryptoRequest(kdf_params={}, email={}, private_key={}, method={})".format(self.kdf_params, self.email, self.private_key, self.method)

    def __eq__(self, other):
        if self.kdf_params != other.kdf_params:
            return False
        if self.email != other.email:
            return False
        if self.private_key != other.private_key:
            return False
        if self.method != other.method:
            return False
        return True

class _UniffiConverterTypeInitUserCryptoRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InitUserCryptoRequest(
            kdf_params=_UniffiConverterTypeKdf.read(buf),
            email=_UniffiConverterString.read(buf),
            private_key=_UniffiConverterString.read(buf),
            method=_UniffiConverterTypeInitUserCryptoMethod.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeKdf.write(value.kdf_params, buf)
        _UniffiConverterString.write(value.email, buf)
        _UniffiConverterString.write(value.private_key, buf)
        _UniffiConverterTypeInitUserCryptoMethod.write(value.method, buf)


class LocalData:
    last_used_date: "typing.Optional[int]"
    last_launched: "typing.Optional[int]"
    @typing.no_type_check
    def __init__(self, last_used_date: "typing.Optional[int]", last_launched: "typing.Optional[int]"):
        self.last_used_date = last_used_date
        self.last_launched = last_launched

    def __str__(self):
        return "LocalData(last_used_date={}, last_launched={})".format(self.last_used_date, self.last_launched)

    def __eq__(self, other):
        if self.last_used_date != other.last_used_date:
            return False
        if self.last_launched != other.last_launched:
            return False
        return True

class _UniffiConverterTypeLocalData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalData(
            last_used_date=_UniffiConverterOptionalUInt32.read(buf),
            last_launched=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt32.write(value.last_used_date, buf)
        _UniffiConverterOptionalUInt32.write(value.last_launched, buf)


class LocalDataView:
    last_used_date: "typing.Optional[int]"
    last_launched: "typing.Optional[int]"
    @typing.no_type_check
    def __init__(self, last_used_date: "typing.Optional[int]", last_launched: "typing.Optional[int]"):
        self.last_used_date = last_used_date
        self.last_launched = last_launched

    def __str__(self):
        return "LocalDataView(last_used_date={}, last_launched={})".format(self.last_used_date, self.last_launched)

    def __eq__(self, other):
        if self.last_used_date != other.last_used_date:
            return False
        if self.last_launched != other.last_launched:
            return False
        return True

class _UniffiConverterTypeLocalDataView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalDataView(
            last_used_date=_UniffiConverterOptionalUInt32.read(buf),
            last_launched=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt32.write(value.last_used_date, buf)
        _UniffiConverterOptionalUInt32.write(value.last_launched, buf)


class Login:
    username: "typing.Optional[EncString]"
    password: "typing.Optional[EncString]"
    password_revision_date: "typing.Optional[DateTime]"
    uris: "typing.Optional[typing.List[LoginUri]]"
    totp: "typing.Optional[EncString]"
    autofill_on_page_load: "typing.Optional[bool]"
    @typing.no_type_check
    def __init__(self, username: "typing.Optional[EncString]", password: "typing.Optional[EncString]", password_revision_date: "typing.Optional[DateTime]", uris: "typing.Optional[typing.List[LoginUri]]", totp: "typing.Optional[EncString]", autofill_on_page_load: "typing.Optional[bool]"):
        self.username = username
        self.password = password
        self.password_revision_date = password_revision_date
        self.uris = uris
        self.totp = totp
        self.autofill_on_page_load = autofill_on_page_load

    def __str__(self):
        return "Login(username={}, password={}, password_revision_date={}, uris={}, totp={}, autofill_on_page_load={})".format(self.username, self.password, self.password_revision_date, self.uris, self.totp, self.autofill_on_page_load)

    def __eq__(self, other):
        if self.username != other.username:
            return False
        if self.password != other.password:
            return False
        if self.password_revision_date != other.password_revision_date:
            return False
        if self.uris != other.uris:
            return False
        if self.totp != other.totp:
            return False
        if self.autofill_on_page_load != other.autofill_on_page_load:
            return False
        return True

class _UniffiConverterTypeLogin(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Login(
            username=_UniffiConverterOptionalTypeEncString.read(buf),
            password=_UniffiConverterOptionalTypeEncString.read(buf),
            password_revision_date=_UniffiConverterOptionalTypeDateTime.read(buf),
            uris=_UniffiConverterOptionalSequenceTypeLoginUri.read(buf),
            totp=_UniffiConverterOptionalTypeEncString.read(buf),
            autofill_on_page_load=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeEncString.write(value.username, buf)
        _UniffiConverterOptionalTypeEncString.write(value.password, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.password_revision_date, buf)
        _UniffiConverterOptionalSequenceTypeLoginUri.write(value.uris, buf)
        _UniffiConverterOptionalTypeEncString.write(value.totp, buf)
        _UniffiConverterOptionalBool.write(value.autofill_on_page_load, buf)


class LoginUri:
    uri: "typing.Optional[EncString]"
    match: "typing.Optional[UriMatchType]"
    @typing.no_type_check
    def __init__(self, uri: "typing.Optional[EncString]", match: "typing.Optional[UriMatchType]"):
        self.uri = uri
        self.match = match

    def __str__(self):
        return "LoginUri(uri={}, match={})".format(self.uri, self.match)

    def __eq__(self, other):
        if self.uri != other.uri:
            return False
        if self.match != other.match:
            return False
        return True

class _UniffiConverterTypeLoginUri(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LoginUri(
            uri=_UniffiConverterOptionalTypeEncString.read(buf),
            match=_UniffiConverterOptionalTypeUriMatchType.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeEncString.write(value.uri, buf)
        _UniffiConverterOptionalTypeUriMatchType.write(value.match, buf)


class LoginUriView:
    uri: "typing.Optional[str]"
    match: "typing.Optional[UriMatchType]"
    @typing.no_type_check
    def __init__(self, uri: "typing.Optional[str]", match: "typing.Optional[UriMatchType]"):
        self.uri = uri
        self.match = match

    def __str__(self):
        return "LoginUriView(uri={}, match={})".format(self.uri, self.match)

    def __eq__(self, other):
        if self.uri != other.uri:
            return False
        if self.match != other.match:
            return False
        return True

class _UniffiConverterTypeLoginUriView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LoginUriView(
            uri=_UniffiConverterOptionalString.read(buf),
            match=_UniffiConverterOptionalTypeUriMatchType.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.uri, buf)
        _UniffiConverterOptionalTypeUriMatchType.write(value.match, buf)


class LoginView:
    username: "typing.Optional[str]"
    password: "typing.Optional[str]"
    password_revision_date: "typing.Optional[DateTime]"
    uris: "typing.Optional[typing.List[LoginUriView]]"
    totp: "typing.Optional[str]"
    autofill_on_page_load: "typing.Optional[bool]"
    @typing.no_type_check
    def __init__(self, username: "typing.Optional[str]", password: "typing.Optional[str]", password_revision_date: "typing.Optional[DateTime]", uris: "typing.Optional[typing.List[LoginUriView]]", totp: "typing.Optional[str]", autofill_on_page_load: "typing.Optional[bool]"):
        self.username = username
        self.password = password
        self.password_revision_date = password_revision_date
        self.uris = uris
        self.totp = totp
        self.autofill_on_page_load = autofill_on_page_load

    def __str__(self):
        return "LoginView(username={}, password={}, password_revision_date={}, uris={}, totp={}, autofill_on_page_load={})".format(self.username, self.password, self.password_revision_date, self.uris, self.totp, self.autofill_on_page_load)

    def __eq__(self, other):
        if self.username != other.username:
            return False
        if self.password != other.password:
            return False
        if self.password_revision_date != other.password_revision_date:
            return False
        if self.uris != other.uris:
            return False
        if self.totp != other.totp:
            return False
        if self.autofill_on_page_load != other.autofill_on_page_load:
            return False
        return True

class _UniffiConverterTypeLoginView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LoginView(
            username=_UniffiConverterOptionalString.read(buf),
            password=_UniffiConverterOptionalString.read(buf),
            password_revision_date=_UniffiConverterOptionalTypeDateTime.read(buf),
            uris=_UniffiConverterOptionalSequenceTypeLoginUriView.read(buf),
            totp=_UniffiConverterOptionalString.read(buf),
            autofill_on_page_load=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.username, buf)
        _UniffiConverterOptionalString.write(value.password, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.password_revision_date, buf)
        _UniffiConverterOptionalSequenceTypeLoginUriView.write(value.uris, buf)
        _UniffiConverterOptionalString.write(value.totp, buf)
        _UniffiConverterOptionalBool.write(value.autofill_on_page_load, buf)


class MasterPasswordPolicyOptions:
    min_complexity: "int"
    min_length: "int"
    require_upper: "bool"
    require_lower: "bool"
    require_numbers: "bool"
    require_special: "bool"
    enforce_on_login: "bool"
    """
    Flag to indicate if the policy should be enforced on login.
    If true, and the user's password does not meet the policy requirements,
    the user will be forced to update their password.
    """

    @typing.no_type_check
    def __init__(self, min_complexity: "int", min_length: "int", require_upper: "bool", require_lower: "bool", require_numbers: "bool", require_special: "bool", enforce_on_login: "bool"):
        self.min_complexity = min_complexity
        self.min_length = min_length
        self.require_upper = require_upper
        self.require_lower = require_lower
        self.require_numbers = require_numbers
        self.require_special = require_special
        self.enforce_on_login = enforce_on_login

    def __str__(self):
        return "MasterPasswordPolicyOptions(min_complexity={}, min_length={}, require_upper={}, require_lower={}, require_numbers={}, require_special={}, enforce_on_login={})".format(self.min_complexity, self.min_length, self.require_upper, self.require_lower, self.require_numbers, self.require_special, self.enforce_on_login)

    def __eq__(self, other):
        if self.min_complexity != other.min_complexity:
            return False
        if self.min_length != other.min_length:
            return False
        if self.require_upper != other.require_upper:
            return False
        if self.require_lower != other.require_lower:
            return False
        if self.require_numbers != other.require_numbers:
            return False
        if self.require_special != other.require_special:
            return False
        if self.enforce_on_login != other.enforce_on_login:
            return False
        return True

class _UniffiConverterTypeMasterPasswordPolicyOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MasterPasswordPolicyOptions(
            min_complexity=_UniffiConverterUInt8.read(buf),
            min_length=_UniffiConverterUInt8.read(buf),
            require_upper=_UniffiConverterBool.read(buf),
            require_lower=_UniffiConverterBool.read(buf),
            require_numbers=_UniffiConverterBool.read(buf),
            require_special=_UniffiConverterBool.read(buf),
            enforce_on_login=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.min_complexity, buf)
        _UniffiConverterUInt8.write(value.min_length, buf)
        _UniffiConverterBool.write(value.require_upper, buf)
        _UniffiConverterBool.write(value.require_lower, buf)
        _UniffiConverterBool.write(value.require_numbers, buf)
        _UniffiConverterBool.write(value.require_special, buf)
        _UniffiConverterBool.write(value.enforce_on_login, buf)


class PassphraseGeneratorRequest:
    """Passphrase generator request options."""

    num_words: "int"
    """
    Number of words in the generated passphrase.
    This value must be between 3 and 20.
    """

    word_separator: "str"
    """Character separator between words in the generated passphrase. The value cannot be empty."""

    capitalize: "bool"
    """When set to true, capitalize the first letter of each word in the generated passphrase."""

    include_number: "bool"
    """When set to true, include a number at the end of one of the words in the generated passphrase."""

    @typing.no_type_check
    def __init__(self, num_words: "int", word_separator: "str", capitalize: "bool", include_number: "bool"):
        self.num_words = num_words
        self.word_separator = word_separator
        self.capitalize = capitalize
        self.include_number = include_number

    def __str__(self):
        return "PassphraseGeneratorRequest(num_words={}, word_separator={}, capitalize={}, include_number={})".format(self.num_words, self.word_separator, self.capitalize, self.include_number)

    def __eq__(self, other):
        if self.num_words != other.num_words:
            return False
        if self.word_separator != other.word_separator:
            return False
        if self.capitalize != other.capitalize:
            return False
        if self.include_number != other.include_number:
            return False
        return True

class _UniffiConverterTypePassphraseGeneratorRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PassphraseGeneratorRequest(
            num_words=_UniffiConverterUInt8.read(buf),
            word_separator=_UniffiConverterString.read(buf),
            capitalize=_UniffiConverterBool.read(buf),
            include_number=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.num_words, buf)
        _UniffiConverterString.write(value.word_separator, buf)
        _UniffiConverterBool.write(value.capitalize, buf)
        _UniffiConverterBool.write(value.include_number, buf)


class PasswordGeneratorRequest:
    """Password generator request options."""

    lowercase: "bool"
    """Include lowercase characters (a-z)."""

    uppercase: "bool"
    """Include uppercase characters (A-Z)."""

    numbers: "bool"
    """Include numbers (0-9)."""

    special: "bool"
    """Include special characters: ! @ # $ % ^ & *"""

    length: "int"
    """
    The length of the generated password.
    Note that the password length must be greater than the sum of all the minimums.
    """

    avoid_ambiguous: "bool"
    """
    When set to true, the generated password will not contain ambiguous characters.
    The ambiguous characters are: I, O, l, 0, 1
    """

    min_lowercase: "typing.Optional[int]"
    """
    The minimum number of lowercase characters in the generated password.
    When set, the value must be between 1 and 9. This value is ignored is lowercase is false
    """

    min_uppercase: "typing.Optional[int]"
    """
    The minimum number of uppercase characters in the generated password.
    When set, the value must be between 1 and 9. This value is ignored is uppercase is false
    """

    min_number: "typing.Optional[int]"
    """
    The minimum number of numbers in the generated password.
    When set, the value must be between 1 and 9. This value is ignored is numbers is false
    """

    min_special: "typing.Optional[int]"
    """
    The minimum number of special characters in the generated password.
    When set, the value must be between 1 and 9. This value is ignored is special is false
    """

    @typing.no_type_check
    def __init__(self, lowercase: "bool", uppercase: "bool", numbers: "bool", special: "bool", length: "int", avoid_ambiguous: "bool", min_lowercase: "typing.Optional[int]", min_uppercase: "typing.Optional[int]", min_number: "typing.Optional[int]", min_special: "typing.Optional[int]"):
        self.lowercase = lowercase
        self.uppercase = uppercase
        self.numbers = numbers
        self.special = special
        self.length = length
        self.avoid_ambiguous = avoid_ambiguous
        self.min_lowercase = min_lowercase
        self.min_uppercase = min_uppercase
        self.min_number = min_number
        self.min_special = min_special

    def __str__(self):
        return "PasswordGeneratorRequest(lowercase={}, uppercase={}, numbers={}, special={}, length={}, avoid_ambiguous={}, min_lowercase={}, min_uppercase={}, min_number={}, min_special={})".format(self.lowercase, self.uppercase, self.numbers, self.special, self.length, self.avoid_ambiguous, self.min_lowercase, self.min_uppercase, self.min_number, self.min_special)

    def __eq__(self, other):
        if self.lowercase != other.lowercase:
            return False
        if self.uppercase != other.uppercase:
            return False
        if self.numbers != other.numbers:
            return False
        if self.special != other.special:
            return False
        if self.length != other.length:
            return False
        if self.avoid_ambiguous != other.avoid_ambiguous:
            return False
        if self.min_lowercase != other.min_lowercase:
            return False
        if self.min_uppercase != other.min_uppercase:
            return False
        if self.min_number != other.min_number:
            return False
        if self.min_special != other.min_special:
            return False
        return True

class _UniffiConverterTypePasswordGeneratorRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PasswordGeneratorRequest(
            lowercase=_UniffiConverterBool.read(buf),
            uppercase=_UniffiConverterBool.read(buf),
            numbers=_UniffiConverterBool.read(buf),
            special=_UniffiConverterBool.read(buf),
            length=_UniffiConverterUInt8.read(buf),
            avoid_ambiguous=_UniffiConverterBool.read(buf),
            min_lowercase=_UniffiConverterOptionalUInt8.read(buf),
            min_uppercase=_UniffiConverterOptionalUInt8.read(buf),
            min_number=_UniffiConverterOptionalUInt8.read(buf),
            min_special=_UniffiConverterOptionalUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.lowercase, buf)
        _UniffiConverterBool.write(value.uppercase, buf)
        _UniffiConverterBool.write(value.numbers, buf)
        _UniffiConverterBool.write(value.special, buf)
        _UniffiConverterUInt8.write(value.length, buf)
        _UniffiConverterBool.write(value.avoid_ambiguous, buf)
        _UniffiConverterOptionalUInt8.write(value.min_lowercase, buf)
        _UniffiConverterOptionalUInt8.write(value.min_uppercase, buf)
        _UniffiConverterOptionalUInt8.write(value.min_number, buf)
        _UniffiConverterOptionalUInt8.write(value.min_special, buf)


class PasswordHistory:
    password: "EncString"
    last_used_date: "DateTime"
    @typing.no_type_check
    def __init__(self, password: "EncString", last_used_date: "DateTime"):
        self.password = password
        self.last_used_date = last_used_date

    def __str__(self):
        return "PasswordHistory(password={}, last_used_date={})".format(self.password, self.last_used_date)

    def __eq__(self, other):
        if self.password != other.password:
            return False
        if self.last_used_date != other.last_used_date:
            return False
        return True

class _UniffiConverterTypePasswordHistory(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PasswordHistory(
            password=_UniffiConverterTypeEncString.read(buf),
            last_used_date=_UniffiConverterTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncString.write(value.password, buf)
        _UniffiConverterTypeDateTime.write(value.last_used_date, buf)


class PasswordHistoryView:
    password: "str"
    last_used_date: "DateTime"
    @typing.no_type_check
    def __init__(self, password: "str", last_used_date: "DateTime"):
        self.password = password
        self.last_used_date = last_used_date

    def __str__(self):
        return "PasswordHistoryView(password={}, last_used_date={})".format(self.password, self.last_used_date)

    def __eq__(self, other):
        if self.password != other.password:
            return False
        if self.last_used_date != other.last_used_date:
            return False
        return True

class _UniffiConverterTypePasswordHistoryView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PasswordHistoryView(
            password=_UniffiConverterString.read(buf),
            last_used_date=_UniffiConverterTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.password, buf)
        _UniffiConverterTypeDateTime.write(value.last_used_date, buf)


class RegisterKeyResponse:
    master_password_hash: "str"
    encrypted_user_key: "str"
    keys: "RsaKeyPair"
    @typing.no_type_check
    def __init__(self, master_password_hash: "str", encrypted_user_key: "str", keys: "RsaKeyPair"):
        self.master_password_hash = master_password_hash
        self.encrypted_user_key = encrypted_user_key
        self.keys = keys

    def __str__(self):
        return "RegisterKeyResponse(master_password_hash={}, encrypted_user_key={}, keys={})".format(self.master_password_hash, self.encrypted_user_key, self.keys)

    def __eq__(self, other):
        if self.master_password_hash != other.master_password_hash:
            return False
        if self.encrypted_user_key != other.encrypted_user_key:
            return False
        if self.keys != other.keys:
            return False
        return True

class _UniffiConverterTypeRegisterKeyResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RegisterKeyResponse(
            master_password_hash=_UniffiConverterString.read(buf),
            encrypted_user_key=_UniffiConverterString.read(buf),
            keys=_UniffiConverterTypeRsaKeyPair.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.master_password_hash, buf)
        _UniffiConverterString.write(value.encrypted_user_key, buf)
        _UniffiConverterTypeRsaKeyPair.write(value.keys, buf)


class RsaKeyPair:
    public: "str"
    """Base64 encoded DER representation of the public key"""

    private: "EncString"
    """Encrypted PKCS8 private key"""

    @typing.no_type_check
    def __init__(self, public: "str", private: "EncString"):
        self.public = public
        self.private = private

    def __str__(self):
        return "RsaKeyPair(public={}, private={})".format(self.public, self.private)

    def __eq__(self, other):
        if self.public != other.public:
            return False
        if self.private != other.private:
            return False
        return True

class _UniffiConverterTypeRsaKeyPair(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RsaKeyPair(
            public=_UniffiConverterString.read(buf),
            private=_UniffiConverterTypeEncString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.public, buf)
        _UniffiConverterTypeEncString.write(value.private, buf)


class SecureNote:
    type: "SecureNoteType"
    @typing.no_type_check
    def __init__(self, type: "SecureNoteType"):
        self.type = type

    def __str__(self):
        return "SecureNote(type={})".format(self.type)

    def __eq__(self, other):
        if self.type != other.type:
            return False
        return True

class _UniffiConverterTypeSecureNote(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SecureNote(
            type=_UniffiConverterTypeSecureNoteType.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSecureNoteType.write(value.type, buf)


class SecureNoteView:
    type: "SecureNoteType"
    @typing.no_type_check
    def __init__(self, type: "SecureNoteType"):
        self.type = type

    def __str__(self):
        return "SecureNoteView(type={})".format(self.type)

    def __eq__(self, other):
        if self.type != other.type:
            return False
        return True

class _UniffiConverterTypeSecureNoteView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SecureNoteView(
            type=_UniffiConverterTypeSecureNoteType.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSecureNoteType.write(value.type, buf)


class Send:
    id: "typing.Optional[Uuid]"
    access_id: "typing.Optional[str]"
    name: "EncString"
    notes: "typing.Optional[EncString]"
    key: "EncString"
    password: "typing.Optional[str]"
    type: "SendType"
    file: "typing.Optional[SendFile]"
    text: "typing.Optional[SendText]"
    max_access_count: "typing.Optional[int]"
    access_count: "int"
    disabled: "bool"
    hide_email: "bool"
    revision_date: "DateTime"
    deletion_date: "DateTime"
    expiration_date: "typing.Optional[DateTime]"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", access_id: "typing.Optional[str]", name: "EncString", notes: "typing.Optional[EncString]", key: "EncString", password: "typing.Optional[str]", type: "SendType", file: "typing.Optional[SendFile]", text: "typing.Optional[SendText]", max_access_count: "typing.Optional[int]", access_count: "int", disabled: "bool", hide_email: "bool", revision_date: "DateTime", deletion_date: "DateTime", expiration_date: "typing.Optional[DateTime]"):
        self.id = id
        self.access_id = access_id
        self.name = name
        self.notes = notes
        self.key = key
        self.password = password
        self.type = type
        self.file = file
        self.text = text
        self.max_access_count = max_access_count
        self.access_count = access_count
        self.disabled = disabled
        self.hide_email = hide_email
        self.revision_date = revision_date
        self.deletion_date = deletion_date
        self.expiration_date = expiration_date

    def __str__(self):
        return "Send(id={}, access_id={}, name={}, notes={}, key={}, password={}, type={}, file={}, text={}, max_access_count={}, access_count={}, disabled={}, hide_email={}, revision_date={}, deletion_date={}, expiration_date={})".format(self.id, self.access_id, self.name, self.notes, self.key, self.password, self.type, self.file, self.text, self.max_access_count, self.access_count, self.disabled, self.hide_email, self.revision_date, self.deletion_date, self.expiration_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.access_id != other.access_id:
            return False
        if self.name != other.name:
            return False
        if self.notes != other.notes:
            return False
        if self.key != other.key:
            return False
        if self.password != other.password:
            return False
        if self.type != other.type:
            return False
        if self.file != other.file:
            return False
        if self.text != other.text:
            return False
        if self.max_access_count != other.max_access_count:
            return False
        if self.access_count != other.access_count:
            return False
        if self.disabled != other.disabled:
            return False
        if self.hide_email != other.hide_email:
            return False
        if self.revision_date != other.revision_date:
            return False
        if self.deletion_date != other.deletion_date:
            return False
        if self.expiration_date != other.expiration_date:
            return False
        return True

class _UniffiConverterTypeSend(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Send(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            access_id=_UniffiConverterOptionalString.read(buf),
            name=_UniffiConverterTypeEncString.read(buf),
            notes=_UniffiConverterOptionalTypeEncString.read(buf),
            key=_UniffiConverterTypeEncString.read(buf),
            password=_UniffiConverterOptionalString.read(buf),
            type=_UniffiConverterTypeSendType.read(buf),
            file=_UniffiConverterOptionalTypeSendFile.read(buf),
            text=_UniffiConverterOptionalTypeSendText.read(buf),
            max_access_count=_UniffiConverterOptionalUInt32.read(buf),
            access_count=_UniffiConverterUInt32.read(buf),
            disabled=_UniffiConverterBool.read(buf),
            hide_email=_UniffiConverterBool.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
            deletion_date=_UniffiConverterTypeDateTime.read(buf),
            expiration_date=_UniffiConverterOptionalTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.access_id, buf)
        _UniffiConverterTypeEncString.write(value.name, buf)
        _UniffiConverterOptionalTypeEncString.write(value.notes, buf)
        _UniffiConverterTypeEncString.write(value.key, buf)
        _UniffiConverterOptionalString.write(value.password, buf)
        _UniffiConverterTypeSendType.write(value.type, buf)
        _UniffiConverterOptionalTypeSendFile.write(value.file, buf)
        _UniffiConverterOptionalTypeSendText.write(value.text, buf)
        _UniffiConverterOptionalUInt32.write(value.max_access_count, buf)
        _UniffiConverterUInt32.write(value.access_count, buf)
        _UniffiConverterBool.write(value.disabled, buf)
        _UniffiConverterBool.write(value.hide_email, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)
        _UniffiConverterTypeDateTime.write(value.deletion_date, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.expiration_date, buf)


class SendFile:
    id: "str"
    file_name: "EncString"
    size: "str"
    size_name: "str"

    @typing.no_type_check
    def __init__(self, id: "str", file_name: "EncString", size: "str", size_name: "str"):
        self.id = id
        self.file_name = file_name
        self.size = size
        self.size_name = size_name

    def __str__(self):
        return "SendFile(id={}, file_name={}, size={}, size_name={})".format(self.id, self.file_name, self.size, self.size_name)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.file_name != other.file_name:
            return False
        if self.size != other.size:
            return False
        if self.size_name != other.size_name:
            return False
        return True

class _UniffiConverterTypeSendFile(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendFile(
            id=_UniffiConverterString.read(buf),
            file_name=_UniffiConverterTypeEncString.read(buf),
            size=_UniffiConverterString.read(buf),
            size_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterTypeEncString.write(value.file_name, buf)
        _UniffiConverterString.write(value.size, buf)
        _UniffiConverterString.write(value.size_name, buf)


class SendFileView:
    id: "str"
    file_name: "str"
    size: "str"
    size_name: "str"

    @typing.no_type_check
    def __init__(self, id: "str", file_name: "str", size: "str", size_name: "str"):
        self.id = id
        self.file_name = file_name
        self.size = size
        self.size_name = size_name

    def __str__(self):
        return "SendFileView(id={}, file_name={}, size={}, size_name={})".format(self.id, self.file_name, self.size, self.size_name)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.file_name != other.file_name:
            return False
        if self.size != other.size:
            return False
        if self.size_name != other.size_name:
            return False
        return True

class _UniffiConverterTypeSendFileView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendFileView(
            id=_UniffiConverterString.read(buf),
            file_name=_UniffiConverterString.read(buf),
            size=_UniffiConverterString.read(buf),
            size_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.file_name, buf)
        _UniffiConverterString.write(value.size, buf)
        _UniffiConverterString.write(value.size_name, buf)


class SendListView:
    id: "typing.Optional[Uuid]"
    access_id: "typing.Optional[str]"
    name: "str"
    type: "SendType"
    disabled: "bool"
    revision_date: "DateTime"
    deletion_date: "DateTime"
    expiration_date: "typing.Optional[DateTime]"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", access_id: "typing.Optional[str]", name: "str", type: "SendType", disabled: "bool", revision_date: "DateTime", deletion_date: "DateTime", expiration_date: "typing.Optional[DateTime]"):
        self.id = id
        self.access_id = access_id
        self.name = name
        self.type = type
        self.disabled = disabled
        self.revision_date = revision_date
        self.deletion_date = deletion_date
        self.expiration_date = expiration_date

    def __str__(self):
        return "SendListView(id={}, access_id={}, name={}, type={}, disabled={}, revision_date={}, deletion_date={}, expiration_date={})".format(self.id, self.access_id, self.name, self.type, self.disabled, self.revision_date, self.deletion_date, self.expiration_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.access_id != other.access_id:
            return False
        if self.name != other.name:
            return False
        if self.type != other.type:
            return False
        if self.disabled != other.disabled:
            return False
        if self.revision_date != other.revision_date:
            return False
        if self.deletion_date != other.deletion_date:
            return False
        if self.expiration_date != other.expiration_date:
            return False
        return True

class _UniffiConverterTypeSendListView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendListView(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            access_id=_UniffiConverterOptionalString.read(buf),
            name=_UniffiConverterString.read(buf),
            type=_UniffiConverterTypeSendType.read(buf),
            disabled=_UniffiConverterBool.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
            deletion_date=_UniffiConverterTypeDateTime.read(buf),
            expiration_date=_UniffiConverterOptionalTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.access_id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterTypeSendType.write(value.type, buf)
        _UniffiConverterBool.write(value.disabled, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)
        _UniffiConverterTypeDateTime.write(value.deletion_date, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.expiration_date, buf)


class SendText:
    text: "typing.Optional[EncString]"
    hidden: "bool"
    @typing.no_type_check
    def __init__(self, text: "typing.Optional[EncString]", hidden: "bool"):
        self.text = text
        self.hidden = hidden

    def __str__(self):
        return "SendText(text={}, hidden={})".format(self.text, self.hidden)

    def __eq__(self, other):
        if self.text != other.text:
            return False
        if self.hidden != other.hidden:
            return False
        return True

class _UniffiConverterTypeSendText(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendText(
            text=_UniffiConverterOptionalTypeEncString.read(buf),
            hidden=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeEncString.write(value.text, buf)
        _UniffiConverterBool.write(value.hidden, buf)


class SendTextView:
    text: "typing.Optional[str]"
    hidden: "bool"
    @typing.no_type_check
    def __init__(self, text: "typing.Optional[str]", hidden: "bool"):
        self.text = text
        self.hidden = hidden

    def __str__(self):
        return "SendTextView(text={}, hidden={})".format(self.text, self.hidden)

    def __eq__(self, other):
        if self.text != other.text:
            return False
        if self.hidden != other.hidden:
            return False
        return True

class _UniffiConverterTypeSendTextView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendTextView(
            text=_UniffiConverterOptionalString.read(buf),
            hidden=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.text, buf)
        _UniffiConverterBool.write(value.hidden, buf)


class SendView:
    id: "typing.Optional[Uuid]"
    access_id: "typing.Optional[str]"
    name: "str"
    notes: "typing.Optional[str]"
    key: "EncString"
    password: "typing.Optional[str]"
    type: "SendType"
    file: "typing.Optional[SendFileView]"
    text: "typing.Optional[SendTextView]"
    max_access_count: "typing.Optional[int]"
    access_count: "int"
    disabled: "bool"
    hide_email: "bool"
    revision_date: "DateTime"
    deletion_date: "DateTime"
    expiration_date: "typing.Optional[DateTime]"
    @typing.no_type_check
    def __init__(self, id: "typing.Optional[Uuid]", access_id: "typing.Optional[str]", name: "str", notes: "typing.Optional[str]", key: "EncString", password: "typing.Optional[str]", type: "SendType", file: "typing.Optional[SendFileView]", text: "typing.Optional[SendTextView]", max_access_count: "typing.Optional[int]", access_count: "int", disabled: "bool", hide_email: "bool", revision_date: "DateTime", deletion_date: "DateTime", expiration_date: "typing.Optional[DateTime]"):
        self.id = id
        self.access_id = access_id
        self.name = name
        self.notes = notes
        self.key = key
        self.password = password
        self.type = type
        self.file = file
        self.text = text
        self.max_access_count = max_access_count
        self.access_count = access_count
        self.disabled = disabled
        self.hide_email = hide_email
        self.revision_date = revision_date
        self.deletion_date = deletion_date
        self.expiration_date = expiration_date

    def __str__(self):
        return "SendView(id={}, access_id={}, name={}, notes={}, key={}, password={}, type={}, file={}, text={}, max_access_count={}, access_count={}, disabled={}, hide_email={}, revision_date={}, deletion_date={}, expiration_date={})".format(self.id, self.access_id, self.name, self.notes, self.key, self.password, self.type, self.file, self.text, self.max_access_count, self.access_count, self.disabled, self.hide_email, self.revision_date, self.deletion_date, self.expiration_date)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.access_id != other.access_id:
            return False
        if self.name != other.name:
            return False
        if self.notes != other.notes:
            return False
        if self.key != other.key:
            return False
        if self.password != other.password:
            return False
        if self.type != other.type:
            return False
        if self.file != other.file:
            return False
        if self.text != other.text:
            return False
        if self.max_access_count != other.max_access_count:
            return False
        if self.access_count != other.access_count:
            return False
        if self.disabled != other.disabled:
            return False
        if self.hide_email != other.hide_email:
            return False
        if self.revision_date != other.revision_date:
            return False
        if self.deletion_date != other.deletion_date:
            return False
        if self.expiration_date != other.expiration_date:
            return False
        return True

class _UniffiConverterTypeSendView(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendView(
            id=_UniffiConverterOptionalTypeUuid.read(buf),
            access_id=_UniffiConverterOptionalString.read(buf),
            name=_UniffiConverterString.read(buf),
            notes=_UniffiConverterOptionalString.read(buf),
            key=_UniffiConverterTypeEncString.read(buf),
            password=_UniffiConverterOptionalString.read(buf),
            type=_UniffiConverterTypeSendType.read(buf),
            file=_UniffiConverterOptionalTypeSendFileView.read(buf),
            text=_UniffiConverterOptionalTypeSendTextView.read(buf),
            max_access_count=_UniffiConverterOptionalUInt32.read(buf),
            access_count=_UniffiConverterUInt32.read(buf),
            disabled=_UniffiConverterBool.read(buf),
            hide_email=_UniffiConverterBool.read(buf),
            revision_date=_UniffiConverterTypeDateTime.read(buf),
            deletion_date=_UniffiConverterTypeDateTime.read(buf),
            expiration_date=_UniffiConverterOptionalTypeDateTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUuid.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.access_id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.notes, buf)
        _UniffiConverterTypeEncString.write(value.key, buf)
        _UniffiConverterOptionalString.write(value.password, buf)
        _UniffiConverterTypeSendType.write(value.type, buf)
        _UniffiConverterOptionalTypeSendFileView.write(value.file, buf)
        _UniffiConverterOptionalTypeSendTextView.write(value.text, buf)
        _UniffiConverterOptionalUInt32.write(value.max_access_count, buf)
        _UniffiConverterUInt32.write(value.access_count, buf)
        _UniffiConverterBool.write(value.disabled, buf)
        _UniffiConverterBool.write(value.hide_email, buf)
        _UniffiConverterTypeDateTime.write(value.revision_date, buf)
        _UniffiConverterTypeDateTime.write(value.deletion_date, buf)
        _UniffiConverterOptionalTypeDateTime.write(value.expiration_date, buf)


class TotpResponse:
    code: "str"
    """Generated TOTP code"""

    period: "int"
    """Time period"""

    @typing.no_type_check
    def __init__(self, code: "str", period: "int"):
        self.code = code
        self.period = period

    def __str__(self):
        return "TotpResponse(code={}, period={})".format(self.code, self.period)

    def __eq__(self, other):
        if self.code != other.code:
            return False
        if self.period != other.period:
            return False
        return True

class _UniffiConverterTypeTotpResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TotpResponse(
            code=_UniffiConverterString.read(buf),
            period=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.code, buf)
        _UniffiConverterUInt32.write(value.period, buf)





class AppendType:
    def __init__(self):
        raise RuntimeError("AppendType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class RANDOM:
        """Generates a random string of 8 lowercase characters as part of your username"""


        @typing.no_type_check
        def __init__(self,):

            pass


        def __str__(self):
            return "AppendType.RANDOM()".format()

        def __eq__(self, other):
            if not other.is_random():
                return False
            return True
    class WEBSITE_NAME:
        """Uses the websitename as part of your username"""

        website: "str"

        @typing.no_type_check
        def __init__(self,website: "str"):

            self.website = website


        def __str__(self):
            return "AppendType.WEBSITE_NAME(website={})".format(self.website)

        def __eq__(self, other):
            if not other.is_website_name():
                return False
            if self.website != other.website:
                return False
            return True


    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_random(self) -> bool:
        return isinstance(self, AppendType.RANDOM)
    def is_website_name(self) -> bool:
        return isinstance(self, AppendType.WEBSITE_NAME)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AppendType.RANDOM = type("AppendType.RANDOM", (AppendType.RANDOM, AppendType,), {})  # type: ignore
AppendType.WEBSITE_NAME = type("AppendType.WEBSITE_NAME", (AppendType.WEBSITE_NAME, AppendType,), {})  # type: ignore




class _UniffiConverterTypeAppendType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AppendType.RANDOM(
            )
        if variant == 2:
            return AppendType.WEBSITE_NAME(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_random():
            buf.write_i32(1)
        if value.is_website_name():
            buf.write_i32(2)
            _UniffiConverterString.write(value.website, buf)






class CipherRepromptType(enum.Enum):
    NONE = 1

    PASSWORD = 2



class _UniffiConverterTypeCipherRepromptType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CipherRepromptType.NONE
        if variant == 2:
            return CipherRepromptType.PASSWORD
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == CipherRepromptType.NONE:
            buf.write_i32(1)
        if value == CipherRepromptType.PASSWORD:
            buf.write_i32(2)






class CipherType(enum.Enum):
    LOGIN = 1

    SECURE_NOTE = 2

    CARD = 3

    IDENTITY = 4



class _UniffiConverterTypeCipherType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CipherType.LOGIN
        if variant == 2:
            return CipherType.SECURE_NOTE
        if variant == 3:
            return CipherType.CARD
        if variant == 4:
            return CipherType.IDENTITY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == CipherType.LOGIN:
            buf.write_i32(1)
        if value == CipherType.SECURE_NOTE:
            buf.write_i32(2)
        if value == CipherType.CARD:
            buf.write_i32(3)
        if value == CipherType.IDENTITY:
            buf.write_i32(4)






class DeviceType(enum.Enum):
    ANDROID = 1

    I_OS = 2

    CHROME_EXTENSION = 3

    FIREFOX_EXTENSION = 4

    OPERA_EXTENSION = 5

    EDGE_EXTENSION = 6

    WINDOWS_DESKTOP = 7

    MAC_OS_DESKTOP = 8

    LINUX_DESKTOP = 9

    CHROME_BROWSER = 10

    FIREFOX_BROWSER = 11

    OPERA_BROWSER = 12

    EDGE_BROWSER = 13

    IE_BROWSER = 14

    UNKNOWN_BROWSER = 15

    ANDROID_AMAZON = 16

    UWP = 17

    SAFARI_BROWSER = 18

    VIVALDI_BROWSER = 19

    VIVALDI_EXTENSION = 20

    SAFARI_EXTENSION = 21

    SDK = 22



class _UniffiConverterTypeDeviceType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DeviceType.ANDROID
        if variant == 2:
            return DeviceType.I_OS
        if variant == 3:
            return DeviceType.CHROME_EXTENSION
        if variant == 4:
            return DeviceType.FIREFOX_EXTENSION
        if variant == 5:
            return DeviceType.OPERA_EXTENSION
        if variant == 6:
            return DeviceType.EDGE_EXTENSION
        if variant == 7:
            return DeviceType.WINDOWS_DESKTOP
        if variant == 8:
            return DeviceType.MAC_OS_DESKTOP
        if variant == 9:
            return DeviceType.LINUX_DESKTOP
        if variant == 10:
            return DeviceType.CHROME_BROWSER
        if variant == 11:
            return DeviceType.FIREFOX_BROWSER
        if variant == 12:
            return DeviceType.OPERA_BROWSER
        if variant == 13:
            return DeviceType.EDGE_BROWSER
        if variant == 14:
            return DeviceType.IE_BROWSER
        if variant == 15:
            return DeviceType.UNKNOWN_BROWSER
        if variant == 16:
            return DeviceType.ANDROID_AMAZON
        if variant == 17:
            return DeviceType.UWP
        if variant == 18:
            return DeviceType.SAFARI_BROWSER
        if variant == 19:
            return DeviceType.VIVALDI_BROWSER
        if variant == 20:
            return DeviceType.VIVALDI_EXTENSION
        if variant == 21:
            return DeviceType.SAFARI_EXTENSION
        if variant == 22:
            return DeviceType.SDK
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == DeviceType.ANDROID:
            buf.write_i32(1)
        if value == DeviceType.I_OS:
            buf.write_i32(2)
        if value == DeviceType.CHROME_EXTENSION:
            buf.write_i32(3)
        if value == DeviceType.FIREFOX_EXTENSION:
            buf.write_i32(4)
        if value == DeviceType.OPERA_EXTENSION:
            buf.write_i32(5)
        if value == DeviceType.EDGE_EXTENSION:
            buf.write_i32(6)
        if value == DeviceType.WINDOWS_DESKTOP:
            buf.write_i32(7)
        if value == DeviceType.MAC_OS_DESKTOP:
            buf.write_i32(8)
        if value == DeviceType.LINUX_DESKTOP:
            buf.write_i32(9)
        if value == DeviceType.CHROME_BROWSER:
            buf.write_i32(10)
        if value == DeviceType.FIREFOX_BROWSER:
            buf.write_i32(11)
        if value == DeviceType.OPERA_BROWSER:
            buf.write_i32(12)
        if value == DeviceType.EDGE_BROWSER:
            buf.write_i32(13)
        if value == DeviceType.IE_BROWSER:
            buf.write_i32(14)
        if value == DeviceType.UNKNOWN_BROWSER:
            buf.write_i32(15)
        if value == DeviceType.ANDROID_AMAZON:
            buf.write_i32(16)
        if value == DeviceType.UWP:
            buf.write_i32(17)
        if value == DeviceType.SAFARI_BROWSER:
            buf.write_i32(18)
        if value == DeviceType.VIVALDI_BROWSER:
            buf.write_i32(19)
        if value == DeviceType.VIVALDI_EXTENSION:
            buf.write_i32(20)
        if value == DeviceType.SAFARI_EXTENSION:
            buf.write_i32(21)
        if value == DeviceType.SDK:
            buf.write_i32(22)






class ExportFormat:
    def __init__(self):
        raise RuntimeError("ExportFormat cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CSV:

        @typing.no_type_check
        def __init__(self,):

            pass


        def __str__(self):
            return "ExportFormat.CSV()".format()

        def __eq__(self, other):
            if not other.is_csv():
                return False
            return True
    class JSON:

        @typing.no_type_check
        def __init__(self,):

            pass


        def __str__(self):
            return "ExportFormat.JSON()".format()

        def __eq__(self, other):
            if not other.is_json():
                return False
            return True
    class ACCOUNT_ENCRYPTED_JSON:

        @typing.no_type_check
        def __init__(self,):

            pass


        def __str__(self):
            return "ExportFormat.ACCOUNT_ENCRYPTED_JSON()".format()

        def __eq__(self, other):
            if not other.is_account_encrypted_json():
                return False
            return True
    class ENCRYPTED_JSON:
        password: "str"

        @typing.no_type_check
        def __init__(self,password: "str"):

            self.password = password


        def __str__(self):
            return "ExportFormat.ENCRYPTED_JSON(password={})".format(self.password)

        def __eq__(self, other):
            if not other.is_encrypted_json():
                return False
            if self.password != other.password:
                return False
            return True


    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_csv(self) -> bool:
        return isinstance(self, ExportFormat.CSV)
    def is_json(self) -> bool:
        return isinstance(self, ExportFormat.JSON)
    def is_account_encrypted_json(self) -> bool:
        return isinstance(self, ExportFormat.ACCOUNT_ENCRYPTED_JSON)
    def is_encrypted_json(self) -> bool:
        return isinstance(self, ExportFormat.ENCRYPTED_JSON)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ExportFormat.CSV = type("ExportFormat.CSV", (ExportFormat.CSV, ExportFormat,), {})  # type: ignore
ExportFormat.JSON = type("ExportFormat.JSON", (ExportFormat.JSON, ExportFormat,), {})  # type: ignore
ExportFormat.ACCOUNT_ENCRYPTED_JSON = type("ExportFormat.ACCOUNT_ENCRYPTED_JSON", (ExportFormat.ACCOUNT_ENCRYPTED_JSON, ExportFormat,), {})  # type: ignore
ExportFormat.ENCRYPTED_JSON = type("ExportFormat.ENCRYPTED_JSON", (ExportFormat.ENCRYPTED_JSON, ExportFormat,), {})  # type: ignore




class _UniffiConverterTypeExportFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExportFormat.CSV(
            )
        if variant == 2:
            return ExportFormat.JSON(
            )
        if variant == 3:
            return ExportFormat.ACCOUNT_ENCRYPTED_JSON(
            )
        if variant == 4:
            return ExportFormat.ENCRYPTED_JSON(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_csv():
            buf.write_i32(1)
        if value.is_json():
            buf.write_i32(2)
        if value.is_account_encrypted_json():
            buf.write_i32(3)
        if value.is_encrypted_json():
            buf.write_i32(4)
            _UniffiConverterString.write(value.password, buf)






class FieldType(enum.Enum):
    TEXT = 1

    HIDDEN = 2

    BOOLEAN = 3

    LINKED = 4



class _UniffiConverterTypeFieldType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FieldType.TEXT
        if variant == 2:
            return FieldType.HIDDEN
        if variant == 3:
            return FieldType.BOOLEAN
        if variant == 4:
            return FieldType.LINKED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == FieldType.TEXT:
            buf.write_i32(1)
        if value == FieldType.HIDDEN:
            buf.write_i32(2)
        if value == FieldType.BOOLEAN:
            buf.write_i32(3)
        if value == FieldType.LINKED:
            buf.write_i32(4)






class ForwarderServiceType:
    """
    Configures the email forwarding service to use.
    For instructions on how to configure each service, see the documentation:
    <https://bitwarden.com/help/generator/#username-types>
    """

    def __init__(self):
        raise RuntimeError("ForwarderServiceType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ADDY_IO:

        api_token: "str"
        domain: "str"
        base_url: "str"

        @typing.no_type_check
        def __init__(self,api_token: "str", domain: "str", base_url: "str"):

            self.api_token = api_token
            self.domain = domain
            self.base_url = base_url


        def __str__(self):
            return "ForwarderServiceType.ADDY_IO(api_token={}, domain={}, base_url={})".format(self.api_token, self.domain, self.base_url)

        def __eq__(self, other):
            if not other.is_addy_io():
                return False
            if self.api_token != other.api_token:
                return False
            if self.domain != other.domain:
                return False
            if self.base_url != other.base_url:
                return False
            return True
    class DUCK_DUCK_GO:
        token: "str"

        @typing.no_type_check
        def __init__(self,token: "str"):

            self.token = token


        def __str__(self):
            return "ForwarderServiceType.DUCK_DUCK_GO(token={})".format(self.token)

        def __eq__(self, other):
            if not other.is_duck_duck_go():
                return False
            if self.token != other.token:
                return False
            return True
    class FIREFOX:
        api_token: "str"

        @typing.no_type_check
        def __init__(self,api_token: "str"):

            self.api_token = api_token


        def __str__(self):
            return "ForwarderServiceType.FIREFOX(api_token={})".format(self.api_token)

        def __eq__(self, other):
            if not other.is_firefox():
                return False
            if self.api_token != other.api_token:
                return False
            return True
    class FASTMAIL:
        api_token: "str"

        @typing.no_type_check
        def __init__(self,api_token: "str"):

            self.api_token = api_token


        def __str__(self):
            return "ForwarderServiceType.FASTMAIL(api_token={})".format(self.api_token)

        def __eq__(self, other):
            if not other.is_fastmail():
                return False
            if self.api_token != other.api_token:
                return False
            return True
    class FORWARD_EMAIL:
        api_token: "str"
        domain: "str"

        @typing.no_type_check
        def __init__(self,api_token: "str", domain: "str"):

            self.api_token = api_token
            self.domain = domain


        def __str__(self):
            return "ForwarderServiceType.FORWARD_EMAIL(api_token={}, domain={})".format(self.api_token, self.domain)

        def __eq__(self, other):
            if not other.is_forward_email():
                return False
            if self.api_token != other.api_token:
                return False
            if self.domain != other.domain:
                return False
            return True
    class SIMPLE_LOGIN:
        api_key: "str"

        @typing.no_type_check
        def __init__(self,api_key: "str"):

            self.api_key = api_key


        def __str__(self):
            return "ForwarderServiceType.SIMPLE_LOGIN(api_key={})".format(self.api_key)

        def __eq__(self, other):
            if not other.is_simple_login():
                return False
            if self.api_key != other.api_key:
                return False
            return True


    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_addy_io(self) -> bool:
        return isinstance(self, ForwarderServiceType.ADDY_IO)
    def is_duck_duck_go(self) -> bool:
        return isinstance(self, ForwarderServiceType.DUCK_DUCK_GO)
    def is_firefox(self) -> bool:
        return isinstance(self, ForwarderServiceType.FIREFOX)
    def is_fastmail(self) -> bool:
        return isinstance(self, ForwarderServiceType.FASTMAIL)
    def is_forward_email(self) -> bool:
        return isinstance(self, ForwarderServiceType.FORWARD_EMAIL)
    def is_simple_login(self) -> bool:
        return isinstance(self, ForwarderServiceType.SIMPLE_LOGIN)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ForwarderServiceType.ADDY_IO = type("ForwarderServiceType.ADDY_IO", (ForwarderServiceType.ADDY_IO, ForwarderServiceType,), {})  # type: ignore
ForwarderServiceType.DUCK_DUCK_GO = type("ForwarderServiceType.DUCK_DUCK_GO", (ForwarderServiceType.DUCK_DUCK_GO, ForwarderServiceType,), {})  # type: ignore
ForwarderServiceType.FIREFOX = type("ForwarderServiceType.FIREFOX", (ForwarderServiceType.FIREFOX, ForwarderServiceType,), {})  # type: ignore
ForwarderServiceType.FASTMAIL = type("ForwarderServiceType.FASTMAIL", (ForwarderServiceType.FASTMAIL, ForwarderServiceType,), {})  # type: ignore
ForwarderServiceType.FORWARD_EMAIL = type("ForwarderServiceType.FORWARD_EMAIL", (ForwarderServiceType.FORWARD_EMAIL, ForwarderServiceType,), {})  # type: ignore
ForwarderServiceType.SIMPLE_LOGIN = type("ForwarderServiceType.SIMPLE_LOGIN", (ForwarderServiceType.SIMPLE_LOGIN, ForwarderServiceType,), {})  # type: ignore




class _UniffiConverterTypeForwarderServiceType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ForwarderServiceType.ADDY_IO(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ForwarderServiceType.DUCK_DUCK_GO(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ForwarderServiceType.FIREFOX(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ForwarderServiceType.FASTMAIL(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ForwarderServiceType.FORWARD_EMAIL(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return ForwarderServiceType.SIMPLE_LOGIN(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_addy_io():
            buf.write_i32(1)
            _UniffiConverterString.write(value.api_token, buf)
            _UniffiConverterString.write(value.domain, buf)
            _UniffiConverterString.write(value.base_url, buf)
        if value.is_duck_duck_go():
            buf.write_i32(2)
            _UniffiConverterString.write(value.token, buf)
        if value.is_firefox():
            buf.write_i32(3)
            _UniffiConverterString.write(value.api_token, buf)
        if value.is_fastmail():
            buf.write_i32(4)
            _UniffiConverterString.write(value.api_token, buf)
        if value.is_forward_email():
            buf.write_i32(5)
            _UniffiConverterString.write(value.api_token, buf)
            _UniffiConverterString.write(value.domain, buf)
        if value.is_simple_login():
            buf.write_i32(6)
            _UniffiConverterString.write(value.api_key, buf)






class HashPurpose(enum.Enum):
    SERVER_AUTHORIZATION = 1

    LOCAL_AUTHORIZATION = 2



class _UniffiConverterTypeHashPurpose(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return HashPurpose.SERVER_AUTHORIZATION
        if variant == 2:
            return HashPurpose.LOCAL_AUTHORIZATION
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == HashPurpose.SERVER_AUTHORIZATION:
            buf.write_i32(1)
        if value == HashPurpose.LOCAL_AUTHORIZATION:
            buf.write_i32(2)






class InitUserCryptoMethod:
    def __init__(self):
        raise RuntimeError("InitUserCryptoMethod cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PASSWORD:
        password: "str"
        """The user's master password"""

        user_key: "str"
        """The user's encrypted symmetric crypto key"""


        @typing.no_type_check
        def __init__(self,password: "str", user_key: "str"):

            self.password = password
            self.user_key = user_key


        def __str__(self):
            return "InitUserCryptoMethod.PASSWORD(password={}, user_key={})".format(self.password, self.user_key)

        def __eq__(self, other):
            if not other.is_password():
                return False
            if self.password != other.password:
                return False
            if self.user_key != other.user_key:
                return False
            return True
    class DECRYPTED_KEY:
        decrypted_user_key: "str"
        """The user's decrypted encryption key, obtained using `get_user_encryption_key`"""


        @typing.no_type_check
        def __init__(self,decrypted_user_key: "str"):

            self.decrypted_user_key = decrypted_user_key


        def __str__(self):
            return "InitUserCryptoMethod.DECRYPTED_KEY(decrypted_user_key={})".format(self.decrypted_user_key)

        def __eq__(self, other):
            if not other.is_decrypted_key():
                return False
            if self.decrypted_user_key != other.decrypted_user_key:
                return False
            return True
    class PIN:
        pin: "str"
        """The user's PIN"""

        pin_protected_user_key: "EncString"
        """The user's symmetric crypto key, encrypted with the PIN. Use `derive_pin_key` to obtain this."""


        @typing.no_type_check
        def __init__(self,pin: "str", pin_protected_user_key: "EncString"):

            self.pin = pin
            self.pin_protected_user_key = pin_protected_user_key


        def __str__(self):
            return "InitUserCryptoMethod.PIN(pin={}, pin_protected_user_key={})".format(self.pin, self.pin_protected_user_key)

        def __eq__(self, other):
            if not other.is_pin():
                return False
            if self.pin != other.pin:
                return False
            if self.pin_protected_user_key != other.pin_protected_user_key:
                return False
            return True


    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_password(self) -> bool:
        return isinstance(self, InitUserCryptoMethod.PASSWORD)
    def is_decrypted_key(self) -> bool:
        return isinstance(self, InitUserCryptoMethod.DECRYPTED_KEY)
    def is_pin(self) -> bool:
        return isinstance(self, InitUserCryptoMethod.PIN)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
InitUserCryptoMethod.PASSWORD = type("InitUserCryptoMethod.PASSWORD", (InitUserCryptoMethod.PASSWORD, InitUserCryptoMethod,), {})  # type: ignore
InitUserCryptoMethod.DECRYPTED_KEY = type("InitUserCryptoMethod.DECRYPTED_KEY", (InitUserCryptoMethod.DECRYPTED_KEY, InitUserCryptoMethod,), {})  # type: ignore
InitUserCryptoMethod.PIN = type("InitUserCryptoMethod.PIN", (InitUserCryptoMethod.PIN, InitUserCryptoMethod,), {})  # type: ignore




class _UniffiConverterTypeInitUserCryptoMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return InitUserCryptoMethod.PASSWORD(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return InitUserCryptoMethod.DECRYPTED_KEY(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return InitUserCryptoMethod.PIN(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeEncString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_password():
            buf.write_i32(1)
            _UniffiConverterString.write(value.password, buf)
            _UniffiConverterString.write(value.user_key, buf)
        if value.is_decrypted_key():
            buf.write_i32(2)
            _UniffiConverterString.write(value.decrypted_user_key, buf)
        if value.is_pin():
            buf.write_i32(3)
            _UniffiConverterString.write(value.pin, buf)
            _UniffiConverterTypeEncString.write(value.pin_protected_user_key, buf)






class Kdf:
    def __init__(self):
        raise RuntimeError("Kdf cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PBKDF2:
        iterations: "NonZeroU32"

        @typing.no_type_check
        def __init__(self,iterations: "NonZeroU32"):

            self.iterations = iterations


        def __str__(self):
            return "Kdf.PBKDF2(iterations={})".format(self.iterations)

        def __eq__(self, other):
            if not other.is_pbkdf2():
                return False
            if self.iterations != other.iterations:
                return False
            return True
    class ARGON2ID:
        iterations: "NonZeroU32"
        memory: "NonZeroU32"
        parallelism: "NonZeroU32"

        @typing.no_type_check
        def __init__(self,iterations: "NonZeroU32", memory: "NonZeroU32", parallelism: "NonZeroU32"):

            self.iterations = iterations
            self.memory = memory
            self.parallelism = parallelism


        def __str__(self):
            return "Kdf.ARGON2ID(iterations={}, memory={}, parallelism={})".format(self.iterations, self.memory, self.parallelism)

        def __eq__(self, other):
            if not other.is_argon2id():
                return False
            if self.iterations != other.iterations:
                return False
            if self.memory != other.memory:
                return False
            if self.parallelism != other.parallelism:
                return False
            return True


    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_pbkdf2(self) -> bool:
        return isinstance(self, Kdf.PBKDF2)
    def is_argon2id(self) -> bool:
        return isinstance(self, Kdf.ARGON2ID)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Kdf.PBKDF2 = type("Kdf.PBKDF2", (Kdf.PBKDF2, Kdf,), {})  # type: ignore
Kdf.ARGON2ID = type("Kdf.ARGON2ID", (Kdf.ARGON2ID, Kdf,), {})  # type: ignore




class _UniffiConverterTypeKdf(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Kdf.PBKDF2(
                _UniffiConverterTypeNonZeroU32.read(buf),
            )
        if variant == 2:
            return Kdf.ARGON2ID(
                _UniffiConverterTypeNonZeroU32.read(buf),
                _UniffiConverterTypeNonZeroU32.read(buf),
                _UniffiConverterTypeNonZeroU32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_pbkdf2():
            buf.write_i32(1)
            _UniffiConverterTypeNonZeroU32.write(value.iterations, buf)
        if value.is_argon2id():
            buf.write_i32(2)
            _UniffiConverterTypeNonZeroU32.write(value.iterations, buf)
            _UniffiConverterTypeNonZeroU32.write(value.memory, buf)
            _UniffiConverterTypeNonZeroU32.write(value.parallelism, buf)






class SecureNoteType(enum.Enum):
    GENERIC = 1



class _UniffiConverterTypeSecureNoteType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SecureNoteType.GENERIC
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SecureNoteType.GENERIC:
            buf.write_i32(1)






class SendType(enum.Enum):
    TEXT = 1

    FILE = 2



class _UniffiConverterTypeSendType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SendType.TEXT
        if variant == 2:
            return SendType.FILE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SendType.TEXT:
            buf.write_i32(1)
        if value == SendType.FILE:
            buf.write_i32(2)






class UriMatchType(enum.Enum):
    DOMAIN = 1

    HOST = 2

    STARTS_WITH = 3

    EXACT = 4

    REGULAR_EXPRESSION = 5

    NEVER = 6



class _UniffiConverterTypeUriMatchType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UriMatchType.DOMAIN
        if variant == 2:
            return UriMatchType.HOST
        if variant == 3:
            return UriMatchType.STARTS_WITH
        if variant == 4:
            return UriMatchType.EXACT
        if variant == 5:
            return UriMatchType.REGULAR_EXPRESSION
        if variant == 6:
            return UriMatchType.NEVER
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == UriMatchType.DOMAIN:
            buf.write_i32(1)
        if value == UriMatchType.HOST:
            buf.write_i32(2)
        if value == UriMatchType.STARTS_WITH:
            buf.write_i32(3)
        if value == UriMatchType.EXACT:
            buf.write_i32(4)
        if value == UriMatchType.REGULAR_EXPRESSION:
            buf.write_i32(5)
        if value == UriMatchType.NEVER:
            buf.write_i32(6)






class UsernameGeneratorRequest:
    def __init__(self):
        raise RuntimeError("UsernameGeneratorRequest cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class WORD:
        """Generates a single word username"""

        capitalize: "bool"
        """Capitalize the first letter of the word"""

        include_number: "bool"
        """Include a 4 digit number at the end of the word"""


        @typing.no_type_check
        def __init__(self,capitalize: "bool", include_number: "bool"):

            self.capitalize = capitalize
            self.include_number = include_number


        def __str__(self):
            return "UsernameGeneratorRequest.WORD(capitalize={}, include_number={})".format(self.capitalize, self.include_number)

        def __eq__(self, other):
            if not other.is_word():
                return False
            if self.capitalize != other.capitalize:
                return False
            if self.include_number != other.include_number:
                return False
            return True
    class SUBADDRESS:
        """
        Generates an email using your provider's subaddressing capabilities.
        Note that not all providers support this functionality.
        This will generate an address of the format `youremail+generated@domain.tld`
        """

        type: "AppendType"
        """The type of subaddress to add to the base email"""

        email: "str"
        """The full email address to use as the base for the subaddress"""


        @typing.no_type_check
        def __init__(self,type: "AppendType", email: "str"):

            self.type = type
            self.email = email


        def __str__(self):
            return "UsernameGeneratorRequest.SUBADDRESS(type={}, email={})".format(self.type, self.email)

        def __eq__(self, other):
            if not other.is_subaddress():
                return False
            if self.type != other.type:
                return False
            if self.email != other.email:
                return False
            return True
    class CATCHALL:
        type: "AppendType"
        """The type of username to use with the catchall email domain"""

        domain: "str"
        """The domain to use for the catchall email address"""


        @typing.no_type_check
        def __init__(self,type: "AppendType", domain: "str"):

            self.type = type
            self.domain = domain


        def __str__(self):
            return "UsernameGeneratorRequest.CATCHALL(type={}, domain={})".format(self.type, self.domain)

        def __eq__(self, other):
            if not other.is_catchall():
                return False
            if self.type != other.type:
                return False
            if self.domain != other.domain:
                return False
            return True
    class FORWARDED:
        service: "ForwarderServiceType"
        """
        The email forwarding service to use, see [ForwarderServiceType]
        for instructions on how to configure each
        """

        website: "typing.Optional[str]"
        """
        The website for which the email address is being generated
        This is not used in all services, and is only used for display purposes
        """


        @typing.no_type_check
        def __init__(self,service: "ForwarderServiceType", website: "typing.Optional[str]"):

            self.service = service
            self.website = website


        def __str__(self):
            return "UsernameGeneratorRequest.FORWARDED(service={}, website={})".format(self.service, self.website)

        def __eq__(self, other):
            if not other.is_forwarded():
                return False
            if self.service != other.service:
                return False
            if self.website != other.website:
                return False
            return True


    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_word(self) -> bool:
        return isinstance(self, UsernameGeneratorRequest.WORD)
    def is_subaddress(self) -> bool:
        return isinstance(self, UsernameGeneratorRequest.SUBADDRESS)
    def is_catchall(self) -> bool:
        return isinstance(self, UsernameGeneratorRequest.CATCHALL)
    def is_forwarded(self) -> bool:
        return isinstance(self, UsernameGeneratorRequest.FORWARDED)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
UsernameGeneratorRequest.WORD = type("UsernameGeneratorRequest.WORD", (UsernameGeneratorRequest.WORD, UsernameGeneratorRequest,), {})  # type: ignore
UsernameGeneratorRequest.SUBADDRESS = type("UsernameGeneratorRequest.SUBADDRESS", (UsernameGeneratorRequest.SUBADDRESS, UsernameGeneratorRequest,), {})  # type: ignore
UsernameGeneratorRequest.CATCHALL = type("UsernameGeneratorRequest.CATCHALL", (UsernameGeneratorRequest.CATCHALL, UsernameGeneratorRequest,), {})  # type: ignore
UsernameGeneratorRequest.FORWARDED = type("UsernameGeneratorRequest.FORWARDED", (UsernameGeneratorRequest.FORWARDED, UsernameGeneratorRequest,), {})  # type: ignore




class _UniffiConverterTypeUsernameGeneratorRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UsernameGeneratorRequest.WORD(
                _UniffiConverterBool.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return UsernameGeneratorRequest.SUBADDRESS(
                _UniffiConverterTypeAppendType.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return UsernameGeneratorRequest.CATCHALL(
                _UniffiConverterTypeAppendType.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return UsernameGeneratorRequest.FORWARDED(
                _UniffiConverterTypeForwarderServiceType.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_word():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.capitalize, buf)
            _UniffiConverterBool.write(value.include_number, buf)
        if value.is_subaddress():
            buf.write_i32(2)
            _UniffiConverterTypeAppendType.write(value.type, buf)
            _UniffiConverterString.write(value.email, buf)
        if value.is_catchall():
            buf.write_i32(3)
            _UniffiConverterTypeAppendType.write(value.type, buf)
            _UniffiConverterString.write(value.domain, buf)
        if value.is_forwarded():
            buf.write_i32(4)
            _UniffiConverterTypeForwarderServiceType.write(value.service, buf)
            _UniffiConverterOptionalString.write(value.website, buf)




class _UniffiConverterOptionalUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCard(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCard.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCard.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCardView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCardView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCardView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeIdentity(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeIdentity.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeIdentity.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeIdentityView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeIdentityView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeIdentityView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLocalData(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLocalData.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLocalData.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLocalDataView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLocalDataView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLocalDataView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLogin(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLogin.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLogin.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLoginView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLoginView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLoginView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSecureNote(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSecureNote.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSecureNote.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSecureNoteView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSecureNoteView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSecureNoteView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSendFile(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSendFile.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSendFile.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSendFileView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSendFileView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSendFileView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSendText(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSendText.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSendText.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSendTextView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSendTextView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSendTextView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeUriMatchType(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeUriMatchType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeUriMatchType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAttachment(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAttachment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAttachment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAttachmentView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAttachmentView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAttachmentView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeField(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeField.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeField.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeFieldView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeFieldView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeFieldView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeLoginUri(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeLoginUri.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeLoginUri.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeLoginUriView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeLoginUriView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeLoginUriView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePasswordHistory(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePasswordHistory.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePasswordHistory.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePasswordHistoryView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePasswordHistoryView.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePasswordHistoryView.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDateTime(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDateTime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDateTime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEncString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEncString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEncString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLinkedIdType(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLinkedIdType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLinkedIdType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeUuid(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeUuid.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeUuid.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceTypeAttachment(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAttachment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAttachment.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAttachmentView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAttachmentView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAttachmentView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeField(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeField.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeField.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFieldView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFieldView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFieldView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLoginUri(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLoginUri.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLoginUri.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLoginUriView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLoginUriView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLoginUriView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePasswordHistory(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePasswordHistory.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePasswordHistory.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePasswordHistoryView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePasswordHistoryView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePasswordHistoryView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeUuid(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeUuid.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeUuid.read(buf) for i in range(count)
        ]



class _UniffiConverterMapTypeUuidTypeAsymmEncString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeUuid.write(key, buf)
            _UniffiConverterTypeAsymmEncString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeUuid.read(buf)
            val = _UniffiConverterTypeAsymmEncString.read(buf)
            d[key] = val
        return d


# Type alias
AsymmEncString = str

class _UniffiConverterTypeAsymmEncString:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


# Type alias
DateTime = Timestamp

class _UniffiConverterTypeDateTime:
    @staticmethod
    def write(value, buf):
        _UniffiConverterTimestamp.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterTimestamp.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterTimestamp.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterTimestamp.lower(value)


# Type alias
EncString = str

class _UniffiConverterTypeEncString:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


# Type alias
LinkedIdType = int

class _UniffiConverterTypeLinkedIdType:
    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterUInt32.lower(value)


# Type alias
NonZeroU32 = int

class _UniffiConverterTypeNonZeroU32:
    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterUInt32.lower(value)


# Type alias
Uuid = str

class _UniffiConverterTypeUuid:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)

__all__ = [
    "InternalError",
    "AppendType",
    "CipherRepromptType",
    "CipherType",
    "DeviceType",
    "ExportFormat",
    "FieldType",
    "ForwarderServiceType",
    "HashPurpose",
    "InitUserCryptoMethod",
    "Kdf",
    "SecureNoteType",
    "SendType",
    "UriMatchType",
    "UsernameGeneratorRequest",
    "Attachment",
    "AttachmentView",
    "Card",
    "CardView",
    "Cipher",
    "CipherListView",
    "CipherView",
    "ClientSettings",
    "Collection",
    "CollectionView",
    "DerivePinKeyResponse",
    "Field",
    "FieldView",
    "FingerprintRequest",
    "Folder",
    "FolderView",
    "Identity",
    "IdentityView",
    "InitOrgCryptoRequest",
    "InitUserCryptoRequest",
    "LocalData",
    "LocalDataView",
    "Login",
    "LoginUri",
    "LoginUriView",
    "LoginView",
    "MasterPasswordPolicyOptions",
    "PassphraseGeneratorRequest",
    "PasswordGeneratorRequest",
    "PasswordHistory",
    "PasswordHistoryView",
    "RegisterKeyResponse",
    "RsaKeyPair",
    "SecureNote",
    "SecureNoteView",
    "Send",
    "SendFile",
    "SendFileView",
    "SendListView",
    "SendText",
    "SendTextView",
    "SendView",
    "TotpResponse",
]

