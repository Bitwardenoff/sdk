

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import asyncio
import platform
from .bitwarden import Cipher
from .bitwarden import CipherListView
from .bitwarden import CipherView
from .bitwarden import ClientSettings
from .bitwarden import Collection
from .bitwarden import CollectionView
from .bitwarden import DateTime
from .bitwarden import DerivePinKeyResponse
from .bitwarden import ExportFormat
from .bitwarden import FingerprintRequest
from .bitwarden import Folder
from .bitwarden import FolderView
from .bitwarden import HashPurpose
from .bitwarden import InitOrgCryptoRequest
from .bitwarden import InitUserCryptoRequest
from .bitwarden import Kdf
from .bitwarden import MasterPasswordPolicyOptions
from .bitwarden import PassphraseGeneratorRequest
from .bitwarden import PasswordGeneratorRequest
from .bitwarden import PasswordHistory
from .bitwarden import PasswordHistoryView
from .bitwarden import RegisterKeyResponse
from .bitwarden import Send
from .bitwarden import SendListView
from .bitwarden import SendView
from .bitwarden import TotpResponse
from .bitwarden import UsernameGeneratorRequest
from .bitwarden import _UniffiConverterTypeCipher
from .bitwarden import _UniffiConverterTypeCipherListView
from .bitwarden import _UniffiConverterTypeCipherView
from .bitwarden import _UniffiConverterTypeClientSettings
from .bitwarden import _UniffiConverterTypeCollection
from .bitwarden import _UniffiConverterTypeCollectionView
from .bitwarden import _UniffiConverterTypeDateTime
from .bitwarden import _UniffiConverterTypeDerivePinKeyResponse
from .bitwarden import _UniffiConverterTypeExportFormat
from .bitwarden import _UniffiConverterTypeFingerprintRequest
from .bitwarden import _UniffiConverterTypeFolder
from .bitwarden import _UniffiConverterTypeFolderView
from .bitwarden import _UniffiConverterTypeHashPurpose
from .bitwarden import _UniffiConverterTypeInitOrgCryptoRequest
from .bitwarden import _UniffiConverterTypeInitUserCryptoRequest
from .bitwarden import _UniffiConverterTypeKdf
from .bitwarden import _UniffiConverterTypeMasterPasswordPolicyOptions
from .bitwarden import _UniffiConverterTypePassphraseGeneratorRequest
from .bitwarden import _UniffiConverterTypePasswordGeneratorRequest
from .bitwarden import _UniffiConverterTypePasswordHistory
from .bitwarden import _UniffiConverterTypePasswordHistoryView
from .bitwarden import _UniffiConverterTypeRegisterKeyResponse
from .bitwarden import _UniffiConverterTypeSend
from .bitwarden import _UniffiConverterTypeSendListView
from .bitwarden import _UniffiConverterTypeSendView
from .bitwarden import _UniffiConverterTypeTotpResponse
from .bitwarden import _UniffiConverterTypeUsernameGeneratorRequest
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferCipher
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferCipherListView
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferCipherView
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferClientSettings
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferCollection
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferCollectionView
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferDateTime
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferDerivePinKeyResponse
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferExportFormat
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferFingerprintRequest
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferFolder
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferFolderView
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferHashPurpose
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferInitOrgCryptoRequest
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferInitUserCryptoRequest
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferKdf
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferMasterPasswordPolicyOptions
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferPassphraseGeneratorRequest
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferPasswordGeneratorRequest
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferPasswordHistory
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferPasswordHistoryView
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferRegisterKeyResponse
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferSend
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferSendListView
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferSendView
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferTotpResponse
from .bitwarden import _UniffiRustBuffer as _UniffiRustBufferUsernameGeneratorRequest

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)
class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.write_unchecked(cls.check(value), buf)

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("bitwarden_uniffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 25
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_bitwarden_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_bitwarden_uniffi_checksum_method_client_auth() != 39544:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_client_crypto() != 52605:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_client_echo() != 12707:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_client_generators() != 61870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_client_platform() != 42798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_client_vault() != 18969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientauth_hash_password() != 48320:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientauth_make_register_keys() != 52737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientauth_password_strength() != 4133:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientauth_satisfies_policy() != 15280:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientauth_validate_password() != 33585:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt() != 51056:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt_list() != 55518:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_encrypt() != 16939:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt() != 57086:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt_list() != 50770:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_derive_pin_key() != 6374:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_get_user_encryption_key() != 28516:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_org_crypto() != 38980:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_user_crypto() != 38742:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_organization_vault() != 19185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_vault() != 55068:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt() != 52773:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt_list() != 19533:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_encrypt() != 61456:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_passphrase() != 11634:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_password() != 45238:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_username() != 12389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_decrypt_list() != 13786:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_encrypt() != 60400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientplatform_fingerprint() != 64688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt() != 62017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_buffer() != 62984:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_file() != 41813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_list() != 35852:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt() != 30371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_buffer() != 19563:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_file() != 11058:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientvault_ciphers() != 3759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientvault_collections() != 14153:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientvault_folders() != 42428:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientvault_generate_totp() != 43353:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientvault_password_history() != 43934:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_method_clientvault_sends() != 50090:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bitwarden_uniffi_checksum_constructor_client_new() != 54800:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_client.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_client.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_constructor_client_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_constructor_client_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_auth.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_crypto.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_crypto.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_echo.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_echo.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_generators.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_generators.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_platform.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_platform.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_vault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_vault.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientauth.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientauth.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_hash_password.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferKdf,
    _UniffiRustBufferHashPurpose,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_hash_password.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_make_register_keys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferKdf,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_make_register_keys.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_password_strength.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_password_strength.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_satisfies_policy.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBufferMasterPasswordPolicyOptions,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_satisfies_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_validate_password.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_validate_password.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientciphers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientciphers.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferCipher,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt_list.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferCipherView,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientcollections.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientcollections.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferCollection,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt_list.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientcrypto.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientcrypto.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_derive_pin_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_derive_pin_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_get_user_encryption_key.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_get_user_encryption_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_org_crypto.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferInitOrgCryptoRequest,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_org_crypto.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_user_crypto.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferInitUserCryptoRequest,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_user_crypto.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientexporters.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientexporters.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientexporters_export_organization_vault.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferExportFormat,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientexporters_export_organization_vault.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientexporters_export_vault.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferExportFormat,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientexporters_export_vault.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientfolders.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientfolders.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferFolder,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt_list.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferFolderView,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientgenerators.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientgenerators.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_passphrase.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferPassphraseGeneratorRequest,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_passphrase.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_password.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferPasswordGeneratorRequest,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_password.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_username.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferUsernameGeneratorRequest,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_username.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientpasswordhistory.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientpasswordhistory.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_decrypt_list.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_decrypt_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferPasswordHistoryView,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientplatform.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientplatform.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientplatform_fingerprint.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferFingerprintRequest,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientplatform_fingerprint.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientsends.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientsends.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferSend,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_buffer.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferSend,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_buffer.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_file.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferSend,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_file.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_list.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferSendView,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_buffer.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferSend,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_buffer.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_file.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferSend,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_file.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientvault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientvault.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_ciphers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_ciphers.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_collections.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_collections.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_folders.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_folders.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_generate_totp.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_generate_totp.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_password_history.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_password_history.restype = ctypes.c_void_p
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_sends.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_sends.restype = ctypes.c_void_p
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_free.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_free_void.restype = None
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_auth.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_crypto.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_crypto.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_echo.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_echo.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_generators.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_generators.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_platform.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_platform.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_vault.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_client_vault.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_hash_password.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_hash_password.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_make_register_keys.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_make_register_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_password_strength.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_password_strength.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_satisfies_policy.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_satisfies_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_validate_password.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientauth_validate_password.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt_list.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_encrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientciphers_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt_list.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_derive_pin_key.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_derive_pin_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_get_user_encryption_key.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_get_user_encryption_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_org_crypto.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_org_crypto.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_user_crypto.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_user_crypto.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_organization_vault.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_organization_vault.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_vault.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_vault.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt_list.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_encrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientfolders_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_passphrase.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_passphrase.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_password.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_password.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_username.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientgenerators_username.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_decrypt_list.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_decrypt_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_encrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientplatform_fingerprint.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientplatform_fingerprint.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_buffer.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_buffer.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_file.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_file.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_list.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_buffer.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_buffer.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_file.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_file.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_ciphers.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_ciphers.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_collections.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_collections.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_folders.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_folders.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_generate_totp.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_generate_totp.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_password_history.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_password_history.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_sends.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_method_clientvault_sends.restype = ctypes.c_uint16
_UniffiLib.uniffi_bitwarden_uniffi_checksum_constructor_client_new.argtypes = (
)
_UniffiLib.uniffi_bitwarden_uniffi_checksum_constructor_client_new.restype = ctypes.c_uint16
_UniffiLib.ffi_bitwarden_uniffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_bitwarden_uniffi_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationPointerManager = _UniffiPointerManager()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_FUTURE_CONTINUATION_T
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationPointerManager.release_pointer(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = asyncio.get_running_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationPointerManager.new_pointer((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u8(value)

class _UniffiConverterBool(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write_unchecked(cls, value, buf):
        buf.write_u8(value)

    @staticmethod
    def lift(value):
        return value != 0

class _UniffiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = _UniffiConverterString.check(value)
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = _UniffiConverterString.check(value)
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def write(value, buf):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))
        buf.write_i32(len(value))
        buf.write(value)



class ClientProtocol(typing.Protocol):
    def auth(self, ):
        """Auth operations"""

        raise NotImplementedError
    def crypto(self, ):
        """Crypto operations"""

        raise NotImplementedError
    def echo(self, msg: "str"):
        """Test method, echoes back the input"""

        raise NotImplementedError
    def generators(self, ):
        """Generator operations"""

        raise NotImplementedError
    def platform(self, ):
        raise NotImplementedError
    def vault(self, ):
        """Vault item operations"""

        raise NotImplementedError

class Client:

    _pointer: ctypes.c_void_p
    def __init__(self, settings: "typing.Optional[ClientSettings]"):
        """Initialize a new instance of the SDK client"""

        
        self._pointer = _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_constructor_client_new,
        _UniffiConverterOptionalTypeClientSettings.lower(settings))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_client, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def auth(self, ) -> "ClientAuth":
        """Auth operations"""

        return _UniffiConverterTypeClientAuth.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_auth,self._pointer,)
        )






    def crypto(self, ) -> "ClientCrypto":
        """Crypto operations"""

        return _UniffiConverterTypeClientCrypto.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_crypto,self._pointer,)
        )






    def echo(self, msg: "str") -> "str":
        """Test method, echoes back the input"""

        
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_echo,self._pointer,
        _UniffiConverterString.lower(msg))
        )






    def generators(self, ) -> "ClientGenerators":
        """Generator operations"""

        return _UniffiConverterTypeClientGenerators.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_generators,self._pointer,)
        )






    def platform(self, ) -> "ClientPlatform":
        return _UniffiConverterTypeClientPlatform.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_platform,self._pointer,)
        )






    def vault(self, ) -> "ClientVault":
        """Vault item operations"""

        return _UniffiConverterTypeClientVault.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_client_vault,self._pointer,)
        )





class _UniffiConverterTypeClient:

    @staticmethod
    def lift(value: int):
        return Client._make_instance_(value)

    @staticmethod
    def lower(value: ClientProtocol):
        if not isinstance(value, Client):
            raise TypeError("Expected Client instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientAuthProtocol(typing.Protocol):
    def hash_password(self, email: "str",password: "str",kdf_params: "Kdf",purpose: "HashPurpose"):
        """Hash the user password"""

        raise NotImplementedError
    def make_register_keys(self, email: "str",password: "str",kdf: "Kdf"):
        """Generate keys needed for registration process"""

        raise NotImplementedError
    def password_strength(self, password: "str",email: "str",additional_inputs: "typing.List[str]"):
        """**API Draft:** Calculate Password Strength"""

        raise NotImplementedError
    def satisfies_policy(self, password: "str",strength: "int",policy: "MasterPasswordPolicyOptions"):
        """Evaluate if the provided password satisfies the provided policy"""

        raise NotImplementedError
    def validate_password(self, password: "str",password_hash: "str"):
        """
        Validate the user password

        To retrieve the user's password hash, use [`ClientAuth::hash_password`] with
        `HashPurpose::LocalAuthentication` during login and persist it. If the login method has no
        password, use the email OTP.
        """

        raise NotImplementedError

class ClientAuth:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientauth, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def hash_password(self, email: "str",password: "str",kdf_params: "Kdf",purpose: "HashPurpose"):
        """Hash the user password"""

        
        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_hash_password(
                self._pointer, 
        _UniffiConverterString.lower(email),
        _UniffiConverterString.lower(password),
        _UniffiConverterTypeKdf.lower(kdf_params),
        _UniffiConverterTypeHashPurpose.lower(purpose)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def make_register_keys(self, email: "str",password: "str",kdf: "Kdf"):
        """Generate keys needed for registration process"""

        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_make_register_keys(
                self._pointer, 
        _UniffiConverterString.lower(email),
        _UniffiConverterString.lower(password),
        _UniffiConverterTypeKdf.lower(kdf)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRegisterKeyResponse.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def password_strength(self, password: "str",email: "str",additional_inputs: "typing.List[str]"):
        """**API Draft:** Calculate Password Strength"""

        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_password_strength(
                self._pointer, 
        _UniffiConverterString.lower(password),
        _UniffiConverterString.lower(email),
        _UniffiConverterSequenceString.lower(additional_inputs)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_u8,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_u8,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_u8,
            # lift function
            _UniffiConverterUInt8.lift,
            # Error FFI converter
            None,
        )





    def satisfies_policy(self, password: "str",strength: "int",policy: "MasterPasswordPolicyOptions"):
        """Evaluate if the provided password satisfies the provided policy"""

        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_satisfies_policy(
                self._pointer, 
        _UniffiConverterString.lower(password),
        _UniffiConverterUInt8.lower(strength),
        _UniffiConverterTypeMasterPasswordPolicyOptions.lower(policy)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i8,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i8,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            # Error FFI converter
            None,
        )





    def validate_password(self, password: "str",password_hash: "str"):
        """
        Validate the user password

        To retrieve the user's password hash, use [`ClientAuth::hash_password`] with
        `HashPurpose::LocalAuthentication` during login and persist it. If the login method has no
        password, use the email OTP.
        """

        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientauth_validate_password(
                self._pointer, 
        _UniffiConverterString.lower(password),
        _UniffiConverterString.lower(password_hash)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_i8,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_i8,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientAuth:

    @staticmethod
    def lift(value: int):
        return ClientAuth._make_instance_(value)

    @staticmethod
    def lower(value: ClientAuthProtocol):
        if not isinstance(value, ClientAuth):
            raise TypeError("Expected ClientAuth instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientAuthProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientCiphersProtocol(typing.Protocol):
    def decrypt(self, cipher: "Cipher"):
        """Decrypt cipher"""

        raise NotImplementedError
    def decrypt_list(self, ciphers: "typing.List[Cipher]"):
        """Decrypt cipher list"""

        raise NotImplementedError
    def encrypt(self, cipher_view: "CipherView"):
        """Encrypt cipher"""

        raise NotImplementedError

class ClientCiphers:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientciphers, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, cipher: "Cipher"):
        """Decrypt cipher"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt(
                self._pointer, 
        _UniffiConverterTypeCipher.lower(cipher)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeCipherView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def decrypt_list(self, ciphers: "typing.List[Cipher]"):
        """Decrypt cipher list"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt_list(
                self._pointer, 
        _UniffiConverterSequenceTypeCipher.lower(ciphers)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeCipherListView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def encrypt(self, cipher_view: "CipherView"):
        """Encrypt cipher"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientciphers_encrypt(
                self._pointer, 
        _UniffiConverterTypeCipherView.lower(cipher_view)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeCipher.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientCiphers:

    @staticmethod
    def lift(value: int):
        return ClientCiphers._make_instance_(value)

    @staticmethod
    def lower(value: ClientCiphersProtocol):
        if not isinstance(value, ClientCiphers):
            raise TypeError("Expected ClientCiphers instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientCiphersProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientCollectionsProtocol(typing.Protocol):
    def decrypt(self, collection: "Collection"):
        """Decrypt collection"""

        raise NotImplementedError
    def decrypt_list(self, collections: "typing.List[Collection]"):
        """Decrypt collection list"""

        raise NotImplementedError

class ClientCollections:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientcollections, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, collection: "Collection"):
        """Decrypt collection"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt(
                self._pointer, 
        _UniffiConverterTypeCollection.lower(collection)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeCollectionView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def decrypt_list(self, collections: "typing.List[Collection]"):
        """Decrypt collection list"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt_list(
                self._pointer, 
        _UniffiConverterSequenceTypeCollection.lower(collections)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeCollectionView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientCollections:

    @staticmethod
    def lift(value: int):
        return ClientCollections._make_instance_(value)

    @staticmethod
    def lower(value: ClientCollectionsProtocol):
        if not isinstance(value, ClientCollections):
            raise TypeError("Expected ClientCollections instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientCollectionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientCryptoProtocol(typing.Protocol):
    def derive_pin_key(self, pin: "str"):
        """
        Generates a PIN protected user key from the provided PIN. The result can be stored and later used
        to initialize another client instance by using the PIN and the PIN key with `initialize_user_crypto`.
        """

        raise NotImplementedError
    def get_user_encryption_key(self, ):
        """
        Get the uses's decrypted encryption key. Note: It's very important
        to keep this key safe, as it can be used to decrypt all of the user's data
        """

        raise NotImplementedError
    def initialize_org_crypto(self, req: "InitOrgCryptoRequest"):
        """Initialization method for the organization crypto. Needs to be called after `initialize_user_crypto` but before any other crypto operations."""

        raise NotImplementedError
    def initialize_user_crypto(self, req: "InitUserCryptoRequest"):
        """Initialization method for the user crypto. Needs to be called before any other crypto operations."""

        raise NotImplementedError

class ClientCrypto:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientcrypto, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def derive_pin_key(self, pin: "str"):
        """
        Generates a PIN protected user key from the provided PIN. The result can be stored and later used
        to initialize another client instance by using the PIN and the PIN key with `initialize_user_crypto`.
        """

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_derive_pin_key(
                self._pointer, 
        _UniffiConverterString.lower(pin)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDerivePinKeyResponse.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def get_user_encryption_key(self, ):
        """
        Get the uses's decrypted encryption key. Note: It's very important
        to keep this key safe, as it can be used to decrypt all of the user's data
        """

        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_get_user_encryption_key(
                self._pointer, 
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def initialize_org_crypto(self, req: "InitOrgCryptoRequest"):
        """Initialization method for the organization crypto. Needs to be called after `initialize_user_crypto` but before any other crypto operations."""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_org_crypto(
                self._pointer, 
        _UniffiConverterTypeInitOrgCryptoRequest.lower(req)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def initialize_user_crypto(self, req: "InitUserCryptoRequest"):
        """Initialization method for the user crypto. Needs to be called before any other crypto operations."""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_user_crypto(
                self._pointer, 
        _UniffiConverterTypeInitUserCryptoRequest.lower(req)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientCrypto:

    @staticmethod
    def lift(value: int):
        return ClientCrypto._make_instance_(value)

    @staticmethod
    def lower(value: ClientCryptoProtocol):
        if not isinstance(value, ClientCrypto):
            raise TypeError("Expected ClientCrypto instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientCryptoProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientExportersProtocol(typing.Protocol):
    def export_organization_vault(self, collections: "typing.List[Collection]",ciphers: "typing.List[Cipher]",format: "ExportFormat"):
        """**API Draft:** Export organization vault"""

        raise NotImplementedError
    def export_vault(self, folders: "typing.List[Folder]",ciphers: "typing.List[Cipher]",format: "ExportFormat"):
        """**API Draft:** Export user vault"""

        raise NotImplementedError

class ClientExporters:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientexporters, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def export_organization_vault(self, collections: "typing.List[Collection]",ciphers: "typing.List[Cipher]",format: "ExportFormat"):
        """**API Draft:** Export organization vault"""

        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientexporters_export_organization_vault(
                self._pointer, 
        _UniffiConverterSequenceTypeCollection.lower(collections),
        _UniffiConverterSequenceTypeCipher.lower(ciphers),
        _UniffiConverterTypeExportFormat.lower(format)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def export_vault(self, folders: "typing.List[Folder]",ciphers: "typing.List[Cipher]",format: "ExportFormat"):
        """**API Draft:** Export user vault"""

        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientexporters_export_vault(
                self._pointer, 
        _UniffiConverterSequenceTypeFolder.lower(folders),
        _UniffiConverterSequenceTypeCipher.lower(ciphers),
        _UniffiConverterTypeExportFormat.lower(format)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientExporters:

    @staticmethod
    def lift(value: int):
        return ClientExporters._make_instance_(value)

    @staticmethod
    def lower(value: ClientExportersProtocol):
        if not isinstance(value, ClientExporters):
            raise TypeError("Expected ClientExporters instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientExportersProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientFoldersProtocol(typing.Protocol):
    def decrypt(self, folder: "Folder"):
        """Decrypt folder"""

        raise NotImplementedError
    def decrypt_list(self, folders: "typing.List[Folder]"):
        """Decrypt folder list"""

        raise NotImplementedError
    def encrypt(self, folder: "FolderView"):
        """Encrypt folder"""

        raise NotImplementedError

class ClientFolders:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientfolders, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, folder: "Folder"):
        """Decrypt folder"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt(
                self._pointer, 
        _UniffiConverterTypeFolder.lower(folder)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFolderView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def decrypt_list(self, folders: "typing.List[Folder]"):
        """Decrypt folder list"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt_list(
                self._pointer, 
        _UniffiConverterSequenceTypeFolder.lower(folders)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFolderView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def encrypt(self, folder: "FolderView"):
        """Encrypt folder"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientfolders_encrypt(
                self._pointer, 
        _UniffiConverterTypeFolderView.lower(folder)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFolder.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientFolders:

    @staticmethod
    def lift(value: int):
        return ClientFolders._make_instance_(value)

    @staticmethod
    def lower(value: ClientFoldersProtocol):
        if not isinstance(value, ClientFolders):
            raise TypeError("Expected ClientFolders instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientFoldersProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientGeneratorsProtocol(typing.Protocol):
    def passphrase(self, settings: "PassphraseGeneratorRequest"):
        """**API Draft:** Generate Passphrase"""

        raise NotImplementedError
    def password(self, settings: "PasswordGeneratorRequest"):
        """**API Draft:** Generate Password"""

        raise NotImplementedError
    def username(self, settings: "UsernameGeneratorRequest"):
        """**API Draft:** Generate Username"""

        raise NotImplementedError

class ClientGenerators:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientgenerators, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def passphrase(self, settings: "PassphraseGeneratorRequest"):
        """**API Draft:** Generate Passphrase"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_passphrase(
                self._pointer, 
        _UniffiConverterTypePassphraseGeneratorRequest.lower(settings)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def password(self, settings: "PasswordGeneratorRequest"):
        """**API Draft:** Generate Password"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_password(
                self._pointer, 
        _UniffiConverterTypePasswordGeneratorRequest.lower(settings)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def username(self, settings: "UsernameGeneratorRequest"):
        """**API Draft:** Generate Username"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientgenerators_username(
                self._pointer, 
        _UniffiConverterTypeUsernameGeneratorRequest.lower(settings)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientGenerators:

    @staticmethod
    def lift(value: int):
        return ClientGenerators._make_instance_(value)

    @staticmethod
    def lower(value: ClientGeneratorsProtocol):
        if not isinstance(value, ClientGenerators):
            raise TypeError("Expected ClientGenerators instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientGeneratorsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientPasswordHistoryProtocol(typing.Protocol):
    def decrypt_list(self, list: "typing.List[PasswordHistory]"):
        """Decrypt password history"""

        raise NotImplementedError
    def encrypt(self, password_history: "PasswordHistoryView"):
        """Encrypt password history"""

        raise NotImplementedError

class ClientPasswordHistory:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientpasswordhistory, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt_list(self, list: "typing.List[PasswordHistory]"):
        """Decrypt password history"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_decrypt_list(
                self._pointer, 
        _UniffiConverterSequenceTypePasswordHistory.lower(list)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypePasswordHistoryView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def encrypt(self, password_history: "PasswordHistoryView"):
        """Encrypt password history"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_encrypt(
                self._pointer, 
        _UniffiConverterTypePasswordHistoryView.lower(password_history)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePasswordHistory.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientPasswordHistory:

    @staticmethod
    def lift(value: int):
        return ClientPasswordHistory._make_instance_(value)

    @staticmethod
    def lower(value: ClientPasswordHistoryProtocol):
        if not isinstance(value, ClientPasswordHistory):
            raise TypeError("Expected ClientPasswordHistory instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientPasswordHistoryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientPlatformProtocol(typing.Protocol):
    def fingerprint(self, req: "FingerprintRequest"):
        """Fingerprint"""

        raise NotImplementedError

class ClientPlatform:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientplatform, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def fingerprint(self, req: "FingerprintRequest"):
        """Fingerprint"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientplatform_fingerprint(
                self._pointer, 
        _UniffiConverterTypeFingerprintRequest.lower(req)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientPlatform:

    @staticmethod
    def lift(value: int):
        return ClientPlatform._make_instance_(value)

    @staticmethod
    def lower(value: ClientPlatformProtocol):
        if not isinstance(value, ClientPlatform):
            raise TypeError("Expected ClientPlatform instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientPlatformProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientSendsProtocol(typing.Protocol):
    def decrypt(self, send: "Send"):
        """Decrypt send"""

        raise NotImplementedError
    def decrypt_buffer(self, send: "Send",buffer: "bytes"):
        """Decrypt a send file in memory"""

        raise NotImplementedError
    def decrypt_file(self, send: "Send",encrypted_file_path: "str",decrypted_file_path: "str"):
        """Decrypt a send file located in the file system"""

        raise NotImplementedError
    def decrypt_list(self, sends: "typing.List[Send]"):
        """Decrypt send list"""

        raise NotImplementedError
    def encrypt(self, send: "SendView"):
        """Encrypt send"""

        raise NotImplementedError
    def encrypt_buffer(self, send: "Send",buffer: "bytes"):
        """Encrypt a send file in memory"""

        raise NotImplementedError
    def encrypt_file(self, send: "Send",decrypted_file_path: "str",encrypted_file_path: "str"):
        """Encrypt a send file located in the file system"""

        raise NotImplementedError

class ClientSends:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientsends, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, send: "Send"):
        """Decrypt send"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt(
                self._pointer, 
        _UniffiConverterTypeSend.lower(send)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def decrypt_buffer(self, send: "Send",buffer: "bytes"):
        """Decrypt a send file in memory"""

        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_buffer(
                self._pointer, 
        _UniffiConverterTypeSend.lower(send),
        _UniffiConverterBytes.lower(buffer)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def decrypt_file(self, send: "Send",encrypted_file_path: "str",decrypted_file_path: "str"):
        """Decrypt a send file located in the file system"""

        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_file(
                self._pointer, 
        _UniffiConverterTypeSend.lower(send),
        _UniffiConverterString.lower(encrypted_file_path),
        _UniffiConverterString.lower(decrypted_file_path)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def decrypt_list(self, sends: "typing.List[Send]"):
        """Decrypt send list"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_list(
                self._pointer, 
        _UniffiConverterSequenceTypeSend.lower(sends)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeSendListView.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def encrypt(self, send: "SendView"):
        """Encrypt send"""

        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt(
                self._pointer, 
        _UniffiConverterTypeSendView.lower(send)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSend.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def encrypt_buffer(self, send: "Send",buffer: "bytes"):
        """Encrypt a send file in memory"""

        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_buffer(
                self._pointer, 
        _UniffiConverterTypeSend.lower(send),
        _UniffiConverterBytes.lower(buffer)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def encrypt_file(self, send: "Send",decrypted_file_path: "str",encrypted_file_path: "str"):
        """Encrypt a send file located in the file system"""

        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_file(
                self._pointer, 
        _UniffiConverterTypeSend.lower(send),
        _UniffiConverterString.lower(decrypted_file_path),
        _UniffiConverterString.lower(encrypted_file_path)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )




class _UniffiConverterTypeClientSends:

    @staticmethod
    def lift(value: int):
        return ClientSends._make_instance_(value)

    @staticmethod
    def lower(value: ClientSendsProtocol):
        if not isinstance(value, ClientSends):
            raise TypeError("Expected ClientSends instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientSendsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientVaultProtocol(typing.Protocol):
    def ciphers(self, ):
        """Ciphers operations"""

        raise NotImplementedError
    def collections(self, ):
        """Collections operations"""

        raise NotImplementedError
    def folders(self, ):
        """Folder operations"""

        raise NotImplementedError
    def generate_totp(self, key: "str",time: "typing.Optional[DateTime]"):
        """
        Generate a TOTP code from a provided key.

        The key can be either:
        - A base32 encoded string
        - OTP Auth URI
        - Steam URI
        """

        raise NotImplementedError
    def password_history(self, ):
        """Password history operations"""

        raise NotImplementedError
    def sends(self, ):
        """Sends operations"""

        raise NotImplementedError

class ClientVault:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_free_clientvault, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def ciphers(self, ) -> "ClientCiphers":
        """Ciphers operations"""

        return _UniffiConverterTypeClientCiphers.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_ciphers,self._pointer,)
        )






    def collections(self, ) -> "ClientCollections":
        """Collections operations"""

        return _UniffiConverterTypeClientCollections.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_collections,self._pointer,)
        )






    def folders(self, ) -> "ClientFolders":
        """Folder operations"""

        return _UniffiConverterTypeClientFolders.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_folders,self._pointer,)
        )






    def generate_totp(self, key: "str",time: "typing.Optional[DateTime]"):
        """
        Generate a TOTP code from a provided key.

        The key can be either:
        - A base32 encoded string
        - OTP Auth URI
        - Steam URI
        """

        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_generate_totp(
                self._pointer, 
        _UniffiConverterString.lower(key),
        _UniffiConverterOptionalTypeDateTime.lower(time)
            ),
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTotpResponse.lift,
            # Error FFI converter
            _UniffiConverterTypeBitwardenError,
        )





    def password_history(self, ) -> "ClientPasswordHistory":
        """Password history operations"""

        return _UniffiConverterTypeClientPasswordHistory.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_password_history,self._pointer,)
        )






    def sends(self, ) -> "ClientSends":
        """Sends operations"""

        return _UniffiConverterTypeClientSends.lift(
            _rust_call(_UniffiLib.uniffi_bitwarden_uniffi_fn_method_clientvault_sends,self._pointer,)
        )





class _UniffiConverterTypeClientVault:

    @staticmethod
    def lift(value: int):
        return ClientVault._make_instance_(value)

    @staticmethod
    def lower(value: ClientVaultProtocol):
        if not isinstance(value, ClientVault):
            raise TypeError("Expected ClientVault instance, {} found".format(type(value).__name__))
        return value._pointer

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientVaultProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


# BitwardenError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class BitwardenError(Exception):
    pass

_UniffiTempBitwardenError = BitwardenError

class BitwardenError:  # type: ignore
    class E(_UniffiTempBitwardenError):

        def __repr__(self):
            return "BitwardenError.E({})".format(repr(str(self)))
    _UniffiTempBitwardenError.E = E # type: ignore

BitwardenError = _UniffiTempBitwardenError # type: ignore
del _UniffiTempBitwardenError


class _UniffiConverterTypeBitwardenError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BitwardenError.E(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, BitwardenError.E):
            buf.write_i32(1)



class _UniffiConverterOptionalTypeClientSettings(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeClientSettings.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeClientSettings.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDateTime(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDateTime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDateTime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCipher(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCipher.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCipher.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCipherListView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCipherListView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCipherListView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCollection(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCollection.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCollection.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCollectionView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCollectionView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCollectionView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFolder(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFolder.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFolder.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFolderView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFolderView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFolderView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePasswordHistory(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePasswordHistory.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePasswordHistory.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePasswordHistoryView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePasswordHistoryView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePasswordHistoryView.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSend(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSend.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSend.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSendListView(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSendListView.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSendListView.read(buf) for i in range(count)
        ]

# External type Cipher is in namespace "bitwarden", crate bitwarden




# External type CipherListView is in namespace "bitwarden", crate bitwarden




# External type CipherView is in namespace "bitwarden", crate bitwarden




# External type ClientSettings is in namespace "bitwarden", crate bitwarden




# External type Collection is in namespace "bitwarden", crate bitwarden




# External type CollectionView is in namespace "bitwarden", crate bitwarden




# External type DateTime is in namespace "bitwarden", crate bitwarden




# External type DerivePinKeyResponse is in namespace "bitwarden", crate bitwarden




# External type ExportFormat is in namespace "bitwarden", crate bitwarden




# External type FingerprintRequest is in namespace "bitwarden", crate bitwarden




# External type Folder is in namespace "bitwarden", crate bitwarden




# External type FolderView is in namespace "bitwarden", crate bitwarden




# External type HashPurpose is in namespace "bitwarden", crate bitwarden




# External type InitOrgCryptoRequest is in namespace "bitwarden", crate bitwarden




# External type InitUserCryptoRequest is in namespace "bitwarden", crate bitwarden




# External type Kdf is in namespace "bitwarden", crate bitwarden




# External type MasterPasswordPolicyOptions is in namespace "bitwarden", crate bitwarden




# External type PassphraseGeneratorRequest is in namespace "bitwarden", crate bitwarden




# External type PasswordGeneratorRequest is in namespace "bitwarden", crate bitwarden




# External type PasswordHistory is in namespace "bitwarden", crate bitwarden




# External type PasswordHistoryView is in namespace "bitwarden", crate bitwarden




# External type RegisterKeyResponse is in namespace "bitwarden", crate bitwarden




# External type Send is in namespace "bitwarden", crate bitwarden




# External type SendListView is in namespace "bitwarden", crate bitwarden




# External type SendView is in namespace "bitwarden", crate bitwarden




# External type TotpResponse is in namespace "bitwarden", crate bitwarden




# External type UsernameGeneratorRequest is in namespace "bitwarden", crate bitwarden




__all__ = [
    "InternalError",
    "BitwardenError",
    "Client",
    "ClientAuth",
    "ClientCiphers",
    "ClientCollections",
    "ClientCrypto",
    "ClientExporters",
    "ClientFolders",
    "ClientGenerators",
    "ClientPasswordHistory",
    "ClientPlatform",
    "ClientSends",
    "ClientVault",
]

