use reqwest::{header::CONTENT_TYPE, StatusCode};

use crate::error::{Error, Result};
pub async fn generate(
    api_token: String,
    domain: String,
    base_url: String,
    website: Option<String>,
) -> Result<String> {
    if api_token.is_empty() {
        return Err(Error::Internal("Invalid addy.io API token."));
    }
    if domain.is_empty() {
        return Err(Error::Internal("Invalid addy.io domain."));
    }
    if base_url.is_empty() {
        return Err(Error::Internal("Invalid addy.io url."));
    }

    let description = website
        .as_ref()
        .map(|w| format!("Website: {w}. "))
        .unwrap_or_default();
    let description = format!("{description}Generated by Bitwarden.");

    #[derive(serde::Serialize)]
    struct Request {
        domain: String,
        description: String,
    }

    let response = reqwest::Client::new()
        .post(format!("{base_url}/api/v1/aliases"))
        .header(CONTENT_TYPE, "application/json")
        .bearer_auth(api_token)
        .header("X-Requested-With", "XMLHttpRequest")
        .json(&Request {
            domain,
            description,
        })
        .send()
        .await?;

    if response.status() == StatusCode::UNAUTHORIZED {
        return Err(Error::Internal("Invalid addy.io API token."));
    }

    // Throw any other errors
    response.error_for_status_ref()?;

    #[derive(serde::Deserialize)]
    struct ResponseData {
        email: String,
    }
    #[derive(serde::Deserialize)]
    struct Response {
        data: ResponseData,
    }
    let response: Response = response.json().await?;

    Ok(response.data.email)
}
